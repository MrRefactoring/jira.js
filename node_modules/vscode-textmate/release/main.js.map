{"version":3,"file":"main.js","mappings":"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","sources":["webpack://vscodetextmate/webpack/universalModuleDefinition","webpack://vscodetextmate/./out/debug.js","webpack://vscodetextmate/./out/encodedTokenAttributes.js","webpack://vscodetextmate/./out/grammar/basicScopesAttributeProvider.js","webpack://vscodetextmate/./out/grammar/grammar.js","webpack://vscodetextmate/./out/grammar/grammarDependencies.js","webpack://vscodetextmate/./out/grammar/index.js","webpack://vscodetextmate/./out/grammar/tokenizeString.js","webpack://vscodetextmate/./out/json.js","webpack://vscodetextmate/./out/main.js","webpack://vscodetextmate/./out/matcher.js","webpack://vscodetextmate/./out/onigLib.js","webpack://vscodetextmate/./out/parseRawGrammar.js","webpack://vscodetextmate/./out/plist.js","webpack://vscodetextmate/./out/registry.js","webpack://vscodetextmate/./out/rule.js","webpack://vscodetextmate/./out/theme.js","webpack://vscodetextmate/./out/utils.js","webpack://vscodetextmate/webpack/bootstrap","webpack://vscodetextmate/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vscodetextmate\"] = factory();\n\telse\n\t\troot[\"vscodetextmate\"] = factory();\n})(this, function() {\nreturn ","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UseOnigurumaFindOptions = exports.DebugFlags = void 0;\nexports.DebugFlags = {\n    InDebugMode: (typeof process !== 'undefined' && !!process.env['VSCODE_TEXTMATE_DEBUG'])\n};\nexports.UseOnigurumaFindOptions = false;\n//# sourceMappingURL=debug.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toOptionalTokenType = exports.EncodedTokenAttributes = void 0;\nvar EncodedTokenAttributes;\n(function (EncodedTokenAttributes) {\n    function toBinaryStr(encodedTokenAttributes) {\n        let r = encodedTokenAttributes.toString(2);\n        while (r.length < 32) {\n            r = \"0\" + r;\n        }\n        return r;\n    }\n    EncodedTokenAttributes.toBinaryStr = toBinaryStr;\n    function print(encodedTokenAttributes) {\n        const languageId = EncodedTokenAttributes.getLanguageId(encodedTokenAttributes);\n        const tokenType = EncodedTokenAttributes.getTokenType(encodedTokenAttributes);\n        const fontStyle = EncodedTokenAttributes.getFontStyle(encodedTokenAttributes);\n        const foreground = EncodedTokenAttributes.getForeground(encodedTokenAttributes);\n        const background = EncodedTokenAttributes.getBackground(encodedTokenAttributes);\n        console.log({\n            languageId: languageId,\n            tokenType: tokenType,\n            fontStyle: fontStyle,\n            foreground: foreground,\n            background: background,\n        });\n    }\n    EncodedTokenAttributes.print = print;\n    function getLanguageId(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 255 /* LANGUAGEID_MASK */) >>>\n            0 /* LANGUAGEID_OFFSET */);\n    }\n    EncodedTokenAttributes.getLanguageId = getLanguageId;\n    function getTokenType(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */) >>>\n            8 /* TOKEN_TYPE_OFFSET */);\n    }\n    EncodedTokenAttributes.getTokenType = getTokenType;\n    function containsBalancedBrackets(encodedTokenAttributes) {\n        return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    EncodedTokenAttributes.containsBalancedBrackets = containsBalancedBrackets;\n    function getFontStyle(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */) >>>\n            11 /* FONT_STYLE_OFFSET */);\n    }\n    EncodedTokenAttributes.getFontStyle = getFontStyle;\n    function getForeground(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */) >>>\n            15 /* FOREGROUND_OFFSET */);\n    }\n    EncodedTokenAttributes.getForeground = getForeground;\n    function getBackground(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */) >>>\n            24 /* BACKGROUND_OFFSET */);\n    }\n    EncodedTokenAttributes.getBackground = getBackground;\n    /**\n     * Updates the fields in `metadata`.\n     * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n     */\n    function set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n        let _languageId = EncodedTokenAttributes.getLanguageId(encodedTokenAttributes);\n        let _tokenType = EncodedTokenAttributes.getTokenType(encodedTokenAttributes);\n        let _containsBalancedBracketsBit = EncodedTokenAttributes.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n        let _fontStyle = EncodedTokenAttributes.getFontStyle(encodedTokenAttributes);\n        let _foreground = EncodedTokenAttributes.getForeground(encodedTokenAttributes);\n        let _background = EncodedTokenAttributes.getBackground(encodedTokenAttributes);\n        if (languageId !== 0) {\n            _languageId = languageId;\n        }\n        if (tokenType !== 8 /* NotSet */) {\n            _tokenType = fromOptionalTokenType(tokenType);\n        }\n        if (containsBalancedBrackets !== null) {\n            _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n        }\n        if (fontStyle !== -1 /* NotSet */) {\n            _fontStyle = fontStyle;\n        }\n        if (foreground !== 0) {\n            _foreground = foreground;\n        }\n        if (background !== 0) {\n            _background = background;\n        }\n        return (((_languageId << 0 /* LANGUAGEID_OFFSET */) |\n            (_tokenType << 8 /* TOKEN_TYPE_OFFSET */) |\n            (_containsBalancedBracketsBit <<\n                10 /* BALANCED_BRACKETS_OFFSET */) |\n            (_fontStyle << 11 /* FONT_STYLE_OFFSET */) |\n            (_foreground << 15 /* FOREGROUND_OFFSET */) |\n            (_background << 24 /* BACKGROUND_OFFSET */)) >>>\n            0);\n    }\n    EncodedTokenAttributes.set = set;\n})(EncodedTokenAttributes = exports.EncodedTokenAttributes || (exports.EncodedTokenAttributes = {}));\nfunction toOptionalTokenType(standardType) {\n    return standardType;\n}\nexports.toOptionalTokenType = toOptionalTokenType;\nfunction fromOptionalTokenType(standardType) {\n    return standardType;\n}\n//# sourceMappingURL=encodedTokenAttributes.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasicScopeAttributesProvider = exports.BasicScopeAttributes = void 0;\nconst utils_1 = require(\"../utils\");\nclass BasicScopeAttributes {\n    constructor(languageId, tokenType) {\n        this.languageId = languageId;\n        this.tokenType = tokenType;\n    }\n}\nexports.BasicScopeAttributes = BasicScopeAttributes;\nclass BasicScopeAttributesProvider {\n    constructor(initialLanguageId, embeddedLanguages) {\n        this._getBasicScopeAttributes = new utils_1.CachedFn((scopeName) => {\n            const languageId = this._scopeToLanguage(scopeName);\n            const standardTokenType = this._toStandardTokenType(scopeName);\n            return new BasicScopeAttributes(languageId, standardTokenType);\n        });\n        this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */);\n        this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n    }\n    getDefaultAttributes() {\n        return this._defaultAttributes;\n    }\n    getBasicScopeAttributes(scopeName) {\n        if (scopeName === null) {\n            return BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n        }\n        return this._getBasicScopeAttributes.get(scopeName);\n    }\n    /**\n     * Given a produced TM scope, return the language that token describes or null if unknown.\n     * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n     */\n    _scopeToLanguage(scope) {\n        return this._embeddedLanguagesMatcher.match(scope) || 0;\n    }\n    _toStandardTokenType(scopeName) {\n        const m = scopeName.match(BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n        if (!m) {\n            return 8 /* NotSet */;\n        }\n        switch (m[1]) {\n            case \"comment\":\n                return 1 /* Comment */;\n            case \"string\":\n                return 2 /* String */;\n            case \"regex\":\n                return 3 /* RegEx */;\n            case \"meta.embedded\":\n                return 0 /* Other */;\n        }\n        throw new Error(\"Unexpected match for standard token type!\");\n    }\n}\nexports.BasicScopeAttributesProvider = BasicScopeAttributesProvider;\nBasicScopeAttributesProvider._NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\nBasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\nclass ScopeMatcher {\n    constructor(values) {\n        if (values.length === 0) {\n            this.values = null;\n            this.scopesRegExp = null;\n        }\n        else {\n            this.values = new Map(values);\n            // create the regex\n            const escapedScopes = values.map(([scopeName, value]) => utils_1.escapeRegExpCharacters(scopeName));\n            escapedScopes.sort();\n            escapedScopes.reverse(); // Longest scope first\n            this.scopesRegExp = new RegExp(`^((${escapedScopes.join(\")|(\")}))($|\\\\.)`, \"\");\n        }\n    }\n    match(scope) {\n        if (!this.scopesRegExp) {\n            return undefined;\n        }\n        const m = scope.match(this.scopesRegExp);\n        if (!m) {\n            // no scopes matched\n            return undefined;\n        }\n        return this.values.get(m[1]);\n    }\n}\n//# sourceMappingURL=basicScopesAttributeProvider.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LineTokens = exports.BalancedBracketSelectors = exports.StateStack = exports.AttributedScopeStack = exports.Grammar = exports.createGrammar = void 0;\nconst debug_1 = require(\"../debug\");\nconst encodedTokenAttributes_1 = require(\"../encodedTokenAttributes\");\nconst matcher_1 = require(\"../matcher\");\nconst onigLib_1 = require(\"../onigLib\");\nconst rule_1 = require(\"../rule\");\nconst theme_1 = require(\"../theme\");\nconst utils_1 = require(\"../utils\");\nconst basicScopesAttributeProvider_1 = require(\"./basicScopesAttributeProvider\");\nconst tokenizeString_1 = require(\"./tokenizeString\");\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n    return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib); //TODO\n}\nexports.createGrammar = createGrammar;\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n    const matchers = matcher_1.createMatchers(selector, nameMatcher);\n    const ruleId = rule_1.RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n    for (const matcher of matchers) {\n        result.push({\n            debugSelector: selector,\n            matcher: matcher.matcher,\n            ruleId: ruleId,\n            grammar: grammar,\n            priority: matcher.priority\n        });\n    }\n}\nfunction nameMatcher(identifers, scopes) {\n    if (scopes.length < identifers.length) {\n        return false;\n    }\n    let lastIndex = 0;\n    return identifers.every(identifier => {\n        for (let i = lastIndex; i < scopes.length; i++) {\n            if (scopesAreMatching(scopes[i], identifier)) {\n                lastIndex = i + 1;\n                return true;\n            }\n        }\n        return false;\n    });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n    if (!thisScopeName) {\n        return false;\n    }\n    if (thisScopeName === scopeName) {\n        return true;\n    }\n    const len = scopeName.length;\n    return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === '.';\n}\nclass Grammar {\n    constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n        this._rootScopeName = _rootScopeName;\n        this.balancedBracketSelectors = balancedBracketSelectors;\n        this._onigLib = _onigLib;\n        this._basicScopeAttributesProvider = new basicScopesAttributeProvider_1.BasicScopeAttributesProvider(initialLanguage, embeddedLanguages);\n        this._rootId = -1;\n        this._lastRuleId = 0;\n        this._ruleId2desc = [null];\n        this._includedGrammars = {};\n        this._grammarRepository = grammarRepository;\n        this._grammar = initGrammar(grammar, null);\n        this._injections = null;\n        this._tokenTypeMatchers = [];\n        if (tokenTypes) {\n            for (const selector of Object.keys(tokenTypes)) {\n                const matchers = matcher_1.createMatchers(selector, nameMatcher);\n                for (const matcher of matchers) {\n                    this._tokenTypeMatchers.push({\n                        matcher: matcher.matcher,\n                        type: tokenTypes[selector],\n                    });\n                }\n            }\n        }\n    }\n    get themeProvider() { return this._grammarRepository; }\n    dispose() {\n        for (const rule of this._ruleId2desc) {\n            if (rule) {\n                rule.dispose();\n            }\n        }\n    }\n    createOnigScanner(sources) {\n        return this._onigLib.createOnigScanner(sources);\n    }\n    createOnigString(sources) {\n        return this._onigLib.createOnigString(sources);\n    }\n    getMetadataForScope(scope) {\n        return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n    }\n    _collectInjections() {\n        const grammarRepository = {\n            lookup: (scopeName) => {\n                if (scopeName === this._rootScopeName) {\n                    return this._grammar;\n                }\n                return this.getExternalGrammar(scopeName);\n            },\n            injections: (scopeName) => {\n                return this._grammarRepository.injections(scopeName);\n            },\n        };\n        const result = [];\n        const scopeName = this._rootScopeName;\n        const grammar = grammarRepository.lookup(scopeName);\n        if (grammar) {\n            // add injections from the current grammar\n            const rawInjections = grammar.injections;\n            if (rawInjections) {\n                for (let expression in rawInjections) {\n                    collectInjections(result, expression, rawInjections[expression], this, grammar);\n                }\n            }\n            // add injection grammars contributed for the current scope\n            const injectionScopeNames = this._grammarRepository.injections(scopeName);\n            if (injectionScopeNames) {\n                injectionScopeNames.forEach((injectionScopeName) => {\n                    const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n                    if (injectionGrammar) {\n                        const selector = injectionGrammar.injectionSelector;\n                        if (selector) {\n                            collectInjections(result, selector, injectionGrammar, this, injectionGrammar);\n                        }\n                    }\n                });\n            }\n        }\n        result.sort((i1, i2) => i1.priority - i2.priority); // sort by priority\n        return result;\n    }\n    getInjections() {\n        if (this._injections === null) {\n            this._injections = this._collectInjections();\n            if (debug_1.DebugFlags.InDebugMode && this._injections.length > 0) {\n                console.log(`Grammar ${this._rootScopeName} contains the following injections:`);\n                for (const injection of this._injections) {\n                    console.log(`  - ${injection.debugSelector}`);\n                }\n            }\n        }\n        return this._injections;\n    }\n    registerRule(factory) {\n        const id = ++this._lastRuleId;\n        const result = factory(rule_1.ruleIdFromNumber(id));\n        this._ruleId2desc[id] = result;\n        return result;\n    }\n    getRule(ruleId) {\n        return this._ruleId2desc[rule_1.ruleIdToNumber(ruleId)];\n    }\n    getExternalGrammar(scopeName, repository) {\n        if (this._includedGrammars[scopeName]) {\n            return this._includedGrammars[scopeName];\n        }\n        else if (this._grammarRepository) {\n            const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n            if (rawIncludedGrammar) {\n                // console.log('LOADED GRAMMAR ' + pattern.include);\n                this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);\n                return this._includedGrammars[scopeName];\n            }\n        }\n        return undefined;\n    }\n    tokenizeLine(lineText, prevState, timeLimit = 0) {\n        const r = this._tokenize(lineText, prevState, false, timeLimit);\n        return {\n            tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n            ruleStack: r.ruleStack,\n            stoppedEarly: r.stoppedEarly,\n        };\n    }\n    tokenizeLine2(lineText, prevState, timeLimit = 0) {\n        const r = this._tokenize(lineText, prevState, true, timeLimit);\n        return {\n            tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n            ruleStack: r.ruleStack,\n            stoppedEarly: r.stoppedEarly,\n        };\n    }\n    _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n        if (this._rootId === -1) {\n            this._rootId = rule_1.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);\n        }\n        let isFirstLine;\n        if (!prevState || prevState === StateStack.NULL) {\n            isFirstLine = true;\n            const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n            const defaultStyle = this.themeProvider.getDefaults();\n            const defaultMetadata = encodedTokenAttributes_1.EncodedTokenAttributes.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId);\n            const rootScopeName = this.getRule(this._rootId).getName(null, null);\n            let scopeList;\n            if (rootScopeName) {\n                scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this);\n            }\n            else {\n                scopeList = AttributedScopeStack.createRoot(\"unknown\", defaultMetadata);\n            }\n            prevState = new StateStack(null, this._rootId, -1, -1, false, null, scopeList, scopeList);\n        }\n        else {\n            isFirstLine = false;\n            prevState.reset();\n        }\n        lineText = lineText + \"\\n\";\n        const onigLineText = this.createOnigString(lineText);\n        const lineLength = onigLineText.content.length;\n        const lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors);\n        const r = tokenizeString_1._tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, true, timeLimit);\n        onigLib_1.disposeOnigString(onigLineText);\n        return {\n            lineLength: lineLength,\n            lineTokens: lineTokens,\n            ruleStack: r.stack,\n            stoppedEarly: r.stoppedEarly,\n        };\n    }\n}\nexports.Grammar = Grammar;\nfunction initGrammar(grammar, base) {\n    grammar = utils_1.clone(grammar);\n    grammar.repository = grammar.repository || {};\n    grammar.repository.$self = {\n        $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n        patterns: grammar.patterns,\n        name: grammar.scopeName\n    };\n    grammar.repository.$base = base || grammar.repository.$self;\n    return grammar;\n}\nclass AttributedScopeStack {\n    constructor(parent, scopePath, tokenAttributes) {\n        this.parent = parent;\n        this.scopePath = scopePath;\n        this.tokenAttributes = tokenAttributes;\n    }\n    static createRoot(scopeName, tokenAttributes) {\n        return new AttributedScopeStack(null, new theme_1.ScopeStack(null, scopeName), tokenAttributes);\n    }\n    static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n        const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n        const scopePath = new theme_1.ScopeStack(null, scopeName);\n        const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n        const resolvedTokenAttributes = AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);\n        return new AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n    }\n    get scopeName() { return this.scopePath.scopeName; }\n    equals(other) {\n        return AttributedScopeStack._equals(this, other);\n    }\n    static _equals(a, b) {\n        do {\n            if (a === b) {\n                return true;\n            }\n            if (!a && !b) {\n                // End of list reached for both\n                return true;\n            }\n            if (!a || !b) {\n                // End of list reached only for one\n                return false;\n            }\n            if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n                return false;\n            }\n            // Go to previous pair\n            a = a.parent;\n            b = b.parent;\n        } while (true);\n    }\n    static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n        let fontStyle = -1 /* NotSet */;\n        let foreground = 0;\n        let background = 0;\n        if (styleAttributes !== null) {\n            fontStyle = styleAttributes.fontStyle;\n            foreground = styleAttributes.foregroundId;\n            background = styleAttributes.backgroundId;\n        }\n        return encodedTokenAttributes_1.EncodedTokenAttributes.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);\n    }\n    pushAttributed(scopePath, grammar) {\n        if (scopePath === null) {\n            return this;\n        }\n        if (scopePath.indexOf(' ') === -1) {\n            // This is the common case and much faster\n            return AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n        }\n        const scopes = scopePath.split(/ /g);\n        let result = this;\n        for (const scope of scopes) {\n            result = AttributedScopeStack._pushAttributed(result, scope, grammar);\n        }\n        return result;\n    }\n    static _pushAttributed(target, scopeName, grammar) {\n        const rawMetadata = grammar.getMetadataForScope(scopeName);\n        const newPath = target.scopePath.push(scopeName);\n        const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n        const metadata = AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);\n        return new AttributedScopeStack(target, newPath, metadata);\n    }\n    getScopeNames() {\n        return this.scopePath.getSegments();\n    }\n}\nexports.AttributedScopeStack = AttributedScopeStack;\n/**\n * Represents a \"pushed\" state on the stack (as a linked list element).\n */\nclass StateStack {\n    constructor(\n    /**\n     * The previous state on the stack (or null for the root state).\n     */\n    parent, \n    /**\n     * The state (rule) that this element represents.\n     */\n    ruleId, enterPos, anchorPos, \n    /**\n     * The state has entered and captured \\n. This means that the next line should have an anchorPosition of 0.\n     */\n    beginRuleCapturedEOL, \n    /**\n     * The \"pop\" (end) condition for this state in case that it was dynamically generated through captured text.\n     */\n    endRule, \n    /**\n     * The list of scopes containing the \"name\" for this state.\n     */\n    nameScopesList, \n    /**\n     * The list of scopes containing the \"contentName\" (besides \"name\") for this state.\n     * This list **must** contain as an element `scopeName`.\n     */\n    contentNameScopesList) {\n        this.parent = parent;\n        this.ruleId = ruleId;\n        this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n        this.endRule = endRule;\n        this.nameScopesList = nameScopesList;\n        this.contentNameScopesList = contentNameScopesList;\n        this._stackElementBrand = undefined;\n        this.depth = this.parent ? this.parent.depth + 1 : 1;\n        this._enterPos = enterPos;\n        this._anchorPos = anchorPos;\n    }\n    equals(other) {\n        if (other === null) {\n            return false;\n        }\n        return StateStack._equals(this, other);\n    }\n    static _equals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (!this._structuralEquals(a, b)) {\n            return false;\n        }\n        return a.contentNameScopesList.equals(b.contentNameScopesList);\n    }\n    /**\n     * A structural equals check. Does not take into account `scopes`.\n     */\n    static _structuralEquals(a, b) {\n        do {\n            if (a === b) {\n                return true;\n            }\n            if (!a && !b) {\n                // End of list reached for both\n                return true;\n            }\n            if (!a || !b) {\n                // End of list reached only for one\n                return false;\n            }\n            if (a.depth !== b.depth ||\n                a.ruleId !== b.ruleId ||\n                a.endRule !== b.endRule) {\n                return false;\n            }\n            // Go to previous pair\n            a = a.parent;\n            b = b.parent;\n        } while (true);\n    }\n    clone() {\n        return this;\n    }\n    static _reset(el) {\n        while (el) {\n            el._enterPos = -1;\n            el._anchorPos = -1;\n            el = el.parent;\n        }\n    }\n    reset() {\n        StateStack._reset(this);\n    }\n    pop() {\n        return this.parent;\n    }\n    safePop() {\n        if (this.parent) {\n            return this.parent;\n        }\n        return this;\n    }\n    push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n        return new StateStack(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);\n    }\n    getEnterPos() {\n        return this._enterPos;\n    }\n    getAnchorPos() {\n        return this._anchorPos;\n    }\n    getRule(grammar) {\n        return grammar.getRule(this.ruleId);\n    }\n    toString() {\n        const r = [];\n        this._writeString(r, 0);\n        return \"[\" + r.join(\",\") + \"]\";\n    }\n    _writeString(res, outIndex) {\n        if (this.parent) {\n            outIndex = this.parent._writeString(res, outIndex);\n        }\n        res[outIndex++] = `(${this.ruleId}, TODO-${this.nameScopesList}, TODO-${this.contentNameScopesList})`;\n        return outIndex;\n    }\n    withContentNameScopesList(contentNameScopeStack) {\n        if (this.contentNameScopesList === contentNameScopeStack) {\n            return this;\n        }\n        return this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);\n    }\n    withEndRule(endRule) {\n        if (this.endRule === endRule) {\n            return this;\n        }\n        return new StateStack(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);\n    }\n    // Used to warn of endless loops\n    hasSameRuleAs(other) {\n        let el = this;\n        while (el && el._enterPos === other._enterPos) {\n            if (el.ruleId === other.ruleId) {\n                return true;\n            }\n            el = el.parent;\n        }\n        return false;\n    }\n}\nexports.StateStack = StateStack;\n// TODO remove me\nStateStack.NULL = new StateStack(null, 0, 0, 0, false, null, null, null);\nclass BalancedBracketSelectors {\n    constructor(balancedBracketScopes, unbalancedBracketScopes) {\n        this.allowAny = false;\n        this.balancedBracketScopes = balancedBracketScopes.flatMap((selector) => {\n            if (selector === '*') {\n                this.allowAny = true;\n                return [];\n            }\n            return matcher_1.createMatchers(selector, nameMatcher).map((m) => m.matcher);\n        });\n        this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap((selector) => matcher_1.createMatchers(selector, nameMatcher).map((m) => m.matcher));\n    }\n    get matchesAlways() {\n        return this.allowAny && this.unbalancedBracketScopes.length === 0;\n    }\n    get matchesNever() {\n        return this.balancedBracketScopes.length === 0 && !this.allowAny;\n    }\n    match(scopes) {\n        for (const excluder of this.unbalancedBracketScopes) {\n            if (excluder(scopes)) {\n                return false;\n            }\n        }\n        for (const includer of this.balancedBracketScopes) {\n            if (includer(scopes)) {\n                return true;\n            }\n        }\n        return this.allowAny;\n    }\n}\nexports.BalancedBracketSelectors = BalancedBracketSelectors;\nclass LineTokens {\n    constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n        this.balancedBracketSelectors = balancedBracketSelectors;\n        this._emitBinaryTokens = emitBinaryTokens;\n        this._tokenTypeOverrides = tokenTypeOverrides;\n        if (debug_1.DebugFlags.InDebugMode) {\n            this._lineText = lineText;\n        }\n        else {\n            this._lineText = null;\n        }\n        this._tokens = [];\n        this._binaryTokens = [];\n        this._lastTokenEndIndex = 0;\n    }\n    produce(stack, endIndex) {\n        this.produceFromScopes(stack.contentNameScopesList, endIndex);\n    }\n    produceFromScopes(scopesList, endIndex) {\n        if (this._lastTokenEndIndex >= endIndex) {\n            return;\n        }\n        if (this._emitBinaryTokens) {\n            let metadata = scopesList.tokenAttributes;\n            let containsBalancedBrackets = false;\n            if (this.balancedBracketSelectors?.matchesAlways) {\n                containsBalancedBrackets = true;\n            }\n            if (this._tokenTypeOverrides.length > 0 || (this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever)) {\n                // Only generate scope array when required to improve performance\n                const scopes = scopesList.getScopeNames();\n                for (const tokenType of this._tokenTypeOverrides) {\n                    if (tokenType.matcher(scopes)) {\n                        metadata = encodedTokenAttributes_1.EncodedTokenAttributes.set(metadata, 0, encodedTokenAttributes_1.toOptionalTokenType(tokenType.type), null, -1 /* NotSet */, 0, 0);\n                    }\n                }\n                if (this.balancedBracketSelectors) {\n                    containsBalancedBrackets = this.balancedBracketSelectors.match(scopes);\n                }\n            }\n            if (containsBalancedBrackets) {\n                metadata = encodedTokenAttributes_1.EncodedTokenAttributes.set(metadata, 0, 8 /* NotSet */, containsBalancedBrackets, -1 /* NotSet */, 0, 0);\n            }\n            if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n                // no need to push a token with the same metadata\n                this._lastTokenEndIndex = endIndex;\n                return;\n            }\n            if (debug_1.DebugFlags.InDebugMode) {\n                const scopes = scopesList.getScopeNames();\n                console.log('  token: |' + this._lineText.substring(this._lastTokenEndIndex, endIndex).replace(/\\n$/, '\\\\n') + '|');\n                for (let k = 0; k < scopes.length; k++) {\n                    console.log('      * ' + scopes[k]);\n                }\n            }\n            this._binaryTokens.push(this._lastTokenEndIndex);\n            this._binaryTokens.push(metadata);\n            this._lastTokenEndIndex = endIndex;\n            return;\n        }\n        const scopes = scopesList.getScopeNames();\n        if (debug_1.DebugFlags.InDebugMode) {\n            console.log('  token: |' + this._lineText.substring(this._lastTokenEndIndex, endIndex).replace(/\\n$/, '\\\\n') + '|');\n            for (let k = 0; k < scopes.length; k++) {\n                console.log('      * ' + scopes[k]);\n            }\n        }\n        this._tokens.push({\n            startIndex: this._lastTokenEndIndex,\n            endIndex: endIndex,\n            // value: lineText.substring(lastTokenEndIndex, endIndex),\n            scopes: scopes\n        });\n        this._lastTokenEndIndex = endIndex;\n    }\n    getResult(stack, lineLength) {\n        if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n            // pop produced token for newline\n            this._tokens.pop();\n        }\n        if (this._tokens.length === 0) {\n            this._lastTokenEndIndex = -1;\n            this.produce(stack, lineLength);\n            this._tokens[this._tokens.length - 1].startIndex = 0;\n        }\n        return this._tokens;\n    }\n    getBinaryResult(stack, lineLength) {\n        if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n            // pop produced token for newline\n            this._binaryTokens.pop();\n            this._binaryTokens.pop();\n        }\n        if (this._binaryTokens.length === 0) {\n            this._lastTokenEndIndex = -1;\n            this.produce(stack, lineLength);\n            this._binaryTokens[this._binaryTokens.length - 2] = 0;\n        }\n        const result = new Uint32Array(this._binaryTokens.length);\n        for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n            result[i] = this._binaryTokens[i];\n        }\n        return result;\n    }\n}\nexports.LineTokens = LineTokens;\n//# sourceMappingURL=grammar.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseInclude = exports.TopLevelRepositoryReference = exports.TopLevelReference = exports.RelativeReference = exports.SelfReference = exports.BaseReference = exports.ScopeDependencyProcessor = exports.ExternalReferenceCollector = exports.TopLevelRepositoryRuleReference = exports.TopLevelRuleReference = void 0;\nconst utils_1 = require(\"../utils\");\n/**\n * References the top level rule of a grammar with the given scope name.\n*/\nclass TopLevelRuleReference {\n    constructor(scopeName) {\n        this.scopeName = scopeName;\n    }\n    toKey() {\n        return this.scopeName;\n    }\n}\nexports.TopLevelRuleReference = TopLevelRuleReference;\n/**\n * References a rule of a grammar in the top level repository section with the given name.\n*/\nclass TopLevelRepositoryRuleReference {\n    constructor(scopeName, ruleName) {\n        this.scopeName = scopeName;\n        this.ruleName = ruleName;\n    }\n    toKey() {\n        return `${this.scopeName}#${this.ruleName}`;\n    }\n}\nexports.TopLevelRepositoryRuleReference = TopLevelRepositoryRuleReference;\nclass ExternalReferenceCollector {\n    constructor() {\n        this._references = [];\n        this._seenReferenceKeys = new Set();\n        this.visitedRule = new Set();\n    }\n    get references() {\n        return this._references;\n    }\n    add(reference) {\n        const key = reference.toKey();\n        if (this._seenReferenceKeys.has(key)) {\n            return;\n        }\n        this._seenReferenceKeys.add(key);\n        this._references.push(reference);\n    }\n}\nexports.ExternalReferenceCollector = ExternalReferenceCollector;\nclass ScopeDependencyProcessor {\n    constructor(repo, initialScopeName) {\n        this.repo = repo;\n        this.initialScopeName = initialScopeName;\n        this.seenFullScopeRequests = new Set();\n        this.seenPartialScopeRequests = new Set();\n        this.seenFullScopeRequests.add(this.initialScopeName);\n        this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n    }\n    processQueue() {\n        const q = this.Q;\n        this.Q = [];\n        const deps = new ExternalReferenceCollector();\n        for (const dep of q) {\n            collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n        }\n        for (const dep of deps.references) {\n            if (dep instanceof TopLevelRuleReference) {\n                if (this.seenFullScopeRequests.has(dep.scopeName)) {\n                    // already processed\n                    continue;\n                }\n                this.seenFullScopeRequests.add(dep.scopeName);\n                this.Q.push(dep);\n            }\n            else {\n                if (this.seenFullScopeRequests.has(dep.scopeName)) {\n                    // already processed in full\n                    continue;\n                }\n                if (this.seenPartialScopeRequests.has(dep.toKey())) {\n                    // already processed\n                    continue;\n                }\n                this.seenPartialScopeRequests.add(dep.toKey());\n                this.Q.push(dep);\n            }\n        }\n    }\n}\nexports.ScopeDependencyProcessor = ScopeDependencyProcessor;\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n    const selfGrammar = repo.lookup(reference.scopeName);\n    if (!selfGrammar) {\n        if (reference.scopeName === baseGrammarScopeName) {\n            throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n        }\n        return;\n    }\n    const baseGrammar = repo.lookup(baseGrammarScopeName);\n    if (reference instanceof TopLevelRuleReference) {\n        collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n    }\n    else {\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { baseGrammar, selfGrammar, repository: selfGrammar.repository }, result);\n    }\n    const injections = repo.injections(reference.scopeName);\n    if (injections) {\n        for (const injection of injections) {\n            result.add(new TopLevelRuleReference(injection));\n        }\n    }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n    if (context.repository && context.repository[ruleName]) {\n        const rule = context.repository[ruleName];\n        collectExternalReferencesInRules([rule], context, result);\n    }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n    if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n        collectExternalReferencesInRules(context.selfGrammar.patterns, { ...context, repository: context.selfGrammar.repository }, result);\n    }\n    if (context.selfGrammar.injections) {\n        collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), { ...context, repository: context.selfGrammar.repository }, result);\n    }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n    for (const rule of rules) {\n        if (result.visitedRule.has(rule)) {\n            continue;\n        }\n        result.visitedRule.add(rule);\n        const patternRepository = rule.repository ? utils_1.mergeObjects({}, context.repository, rule.repository) : context.repository;\n        if (Array.isArray(rule.patterns)) {\n            collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n        }\n        const include = rule.include;\n        if (!include) {\n            continue;\n        }\n        const reference = parseInclude(include);\n        switch (reference.kind) {\n            case 0 /* Base */:\n                collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n                break;\n            case 1 /* Self */:\n                collectExternalReferencesInTopLevelRule(context, result);\n                break;\n            case 2 /* RelativeReference */:\n                collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n                break;\n            case 3 /* TopLevelReference */:\n            case 4 /* TopLevelRepositoryReference */:\n                const selfGrammar = reference.scopeName === context.selfGrammar.scopeName\n                    ? context.selfGrammar\n                    : reference.scopeName === context.baseGrammar.scopeName\n                        ? context.baseGrammar\n                        : undefined;\n                if (selfGrammar) {\n                    const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n                    if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n                        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n                    }\n                    else {\n                        collectExternalReferencesInTopLevelRule(newContext, result);\n                    }\n                }\n                else {\n                    if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n                        result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n                    }\n                    else {\n                        result.add(new TopLevelRuleReference(reference.scopeName));\n                    }\n                }\n                break;\n        }\n    }\n}\nclass BaseReference {\n    constructor() {\n        this.kind = 0 /* Base */;\n    }\n}\nexports.BaseReference = BaseReference;\nclass SelfReference {\n    constructor() {\n        this.kind = 1 /* Self */;\n    }\n}\nexports.SelfReference = SelfReference;\nclass RelativeReference {\n    constructor(ruleName) {\n        this.ruleName = ruleName;\n        this.kind = 2 /* RelativeReference */;\n    }\n}\nexports.RelativeReference = RelativeReference;\nclass TopLevelReference {\n    constructor(scopeName) {\n        this.scopeName = scopeName;\n        this.kind = 3 /* TopLevelReference */;\n    }\n}\nexports.TopLevelReference = TopLevelReference;\nclass TopLevelRepositoryReference {\n    constructor(scopeName, ruleName) {\n        this.scopeName = scopeName;\n        this.ruleName = ruleName;\n        this.kind = 4 /* TopLevelRepositoryReference */;\n    }\n}\nexports.TopLevelRepositoryReference = TopLevelRepositoryReference;\nfunction parseInclude(include) {\n    if (include === '$base') {\n        return new BaseReference();\n    }\n    else if (include === '$self') {\n        return new SelfReference();\n    }\n    const indexOfSharp = include.indexOf(\"#\");\n    if (indexOfSharp === -1) {\n        return new TopLevelReference(include);\n    }\n    else if (indexOfSharp === 0) {\n        return new RelativeReference(include.substring(1));\n    }\n    else {\n        const scopeName = include.substring(0, indexOfSharp);\n        const ruleName = include.substring(indexOfSharp + 1);\n        return new TopLevelRepositoryReference(scopeName, ruleName);\n    }\n}\nexports.parseInclude = parseInclude;\n//# sourceMappingURL=grammarDependencies.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./grammar\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LocalStackElement = exports._tokenizeString = void 0;\nconst debug_1 = require(\"../debug\");\nconst onigLib_1 = require(\"../onigLib\");\nconst rule_1 = require(\"../rule\");\nconst utils_1 = require(\"../utils\");\nclass TokenizeStringResult {\n    constructor(stack, stoppedEarly) {\n        this.stack = stack;\n        this.stoppedEarly = stoppedEarly;\n    }\n}\n/**\n * Tokenize a string\n * @param grammar\n * @param lineText\n * @param isFirstLine\n * @param linePos\n * @param stack\n * @param lineTokens\n * @param checkWhileConditions\n * @param timeLimit Use `0` to indicate no time limit\n * @returns the StackElement or StackElement.TIME_LIMIT_REACHED if the time limit has been reached\n */\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n    const lineLength = lineText.content.length;\n    let STOP = false;\n    let anchorPosition = -1;\n    if (checkWhileConditions) {\n        const whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);\n        stack = whileCheckResult.stack;\n        linePos = whileCheckResult.linePos;\n        isFirstLine = whileCheckResult.isFirstLine;\n        anchorPosition = whileCheckResult.anchorPosition;\n    }\n    const startTime = Date.now();\n    while (!STOP) {\n        if (timeLimit !== 0) {\n            const elapsedTime = Date.now() - startTime;\n            if (elapsedTime > timeLimit) {\n                return new TokenizeStringResult(stack, true);\n            }\n        }\n        scanNext(); // potentially modifies linePos && anchorPosition\n    }\n    return new TokenizeStringResult(stack, false);\n    function scanNext() {\n        if (debug_1.DebugFlags.InDebugMode) {\n            console.log(\"\");\n            console.log(`@@scanNext ${linePos}: |${lineText.content\n                .substr(linePos)\n                .replace(/\\n$/, \"\\\\n\")}|`);\n        }\n        const r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n        if (!r) {\n            if (debug_1.DebugFlags.InDebugMode) {\n                console.log(\"  no more matches.\");\n            }\n            // No match\n            lineTokens.produce(stack, lineLength);\n            STOP = true;\n            return;\n        }\n        const captureIndices = r.captureIndices;\n        const matchedRuleId = r.matchedRuleId;\n        const hasAdvanced = captureIndices && captureIndices.length > 0\n            ? captureIndices[0].end > linePos\n            : false;\n        if (matchedRuleId === rule_1.endRuleId) {\n            // We matched the `end` for this rule => pop it\n            const poppedRule = stack.getRule(grammar);\n            if (debug_1.DebugFlags.InDebugMode) {\n                console.log(\"  popping \" +\n                    poppedRule.debugName +\n                    \" - \" +\n                    poppedRule.debugEndRegExp);\n            }\n            lineTokens.produce(stack, captureIndices[0].start);\n            stack = stack.withContentNameScopesList(stack.nameScopesList);\n            handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);\n            lineTokens.produce(stack, captureIndices[0].end);\n            // pop\n            const popped = stack;\n            stack = stack.parent;\n            anchorPosition = popped.getAnchorPos();\n            if (!hasAdvanced && popped.getEnterPos() === linePos) {\n                // Grammar pushed & popped a rule without advancing\n                if (debug_1.DebugFlags.InDebugMode) {\n                    console.error(\"[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing\");\n                }\n                // See https://github.com/Microsoft/vscode-textmate/issues/12\n                // Let's assume this was a mistake by the grammar author and the intent was to continue in this state\n                stack = popped;\n                lineTokens.produce(stack, lineLength);\n                STOP = true;\n                return;\n            }\n        }\n        else {\n            // We matched a rule!\n            const _rule = grammar.getRule(matchedRuleId);\n            lineTokens.produce(stack, captureIndices[0].start);\n            const beforePush = stack;\n            // push it on the stack rule\n            const scopeName = _rule.getName(lineText.content, captureIndices);\n            const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n            stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList);\n            if (_rule instanceof rule_1.BeginEndRule) {\n                const pushedRule = _rule;\n                if (debug_1.DebugFlags.InDebugMode) {\n                    console.log(\"  pushing \" +\n                        pushedRule.debugName +\n                        \" - \" +\n                        pushedRule.debugBeginRegExp);\n                }\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                anchorPosition = captureIndices[0].end;\n                const contentName = pushedRule.getContentName(lineText.content, captureIndices);\n                const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n                stack = stack.withContentNameScopesList(contentNameScopesList);\n                if (pushedRule.endHasBackReferences) {\n                    stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices));\n                }\n                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n                    // Grammar pushed the same rule without advancing\n                    if (debug_1.DebugFlags.InDebugMode) {\n                        console.error(\"[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing\");\n                    }\n                    stack = stack.pop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n            else if (_rule instanceof rule_1.BeginWhileRule) {\n                const pushedRule = _rule;\n                if (debug_1.DebugFlags.InDebugMode) {\n                    console.log(\"  pushing \" + pushedRule.debugName);\n                }\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                anchorPosition = captureIndices[0].end;\n                const contentName = pushedRule.getContentName(lineText.content, captureIndices);\n                const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n                stack = stack.withContentNameScopesList(contentNameScopesList);\n                if (pushedRule.whileHasBackReferences) {\n                    stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices));\n                }\n                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n                    // Grammar pushed the same rule without advancing\n                    if (debug_1.DebugFlags.InDebugMode) {\n                        console.error(\"[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing\");\n                    }\n                    stack = stack.pop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n            else {\n                const matchingRule = _rule;\n                if (debug_1.DebugFlags.InDebugMode) {\n                    console.log(\"  matched \" +\n                        matchingRule.debugName +\n                        \" - \" +\n                        matchingRule.debugMatchRegExp);\n                }\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                // pop rule immediately since it is a MatchRule\n                stack = stack.pop();\n                if (!hasAdvanced) {\n                    // Grammar is not advancing, nor is it pushing/popping\n                    if (debug_1.DebugFlags.InDebugMode) {\n                        console.error(\"[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping\");\n                    }\n                    stack = stack.safePop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n        }\n        if (captureIndices[0].end > linePos) {\n            // Advance stream\n            linePos = captureIndices[0].end;\n            isFirstLine = false;\n        }\n    }\n}\nexports._tokenizeString = _tokenizeString;\n/**\n * Walk the stack from bottom to top, and check each while condition in this order.\n * If any fails, cut off the entire stack above the failed while condition. While conditions\n * may also advance the linePosition.\n */\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n    let anchorPosition = (stack.beginRuleCapturedEOL ? 0 : -1);\n    const whileRules = [];\n    for (let node = stack; node; node = node.pop()) {\n        const nodeRule = node.getRule(grammar);\n        if (nodeRule instanceof rule_1.BeginWhileRule) {\n            whileRules.push({\n                rule: nodeRule,\n                stack: node\n            });\n        }\n    }\n    for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n        const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n        const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n        if (debug_1.DebugFlags.InDebugMode) {\n            console.log('  scanning for while rule');\n            console.log(ruleScanner.toString());\n        }\n        if (r) {\n            const matchedRuleId = r.ruleId;\n            if (matchedRuleId !== rule_1.whileRuleId) {\n                // we shouldn't end up here\n                stack = whileRule.stack.pop();\n                break;\n            }\n            if (r.captureIndices && r.captureIndices.length) {\n                lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n                handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n                lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n                anchorPosition = r.captureIndices[0].end;\n                if (r.captureIndices[0].end > linePos) {\n                    linePos = r.captureIndices[0].end;\n                    isFirstLine = false;\n                }\n            }\n        }\n        else {\n            if (debug_1.DebugFlags.InDebugMode) {\n                console.log('  popping ' + whileRule.rule.debugName + ' - ' + whileRule.rule.debugWhileRegExp);\n            }\n            stack = whileRule.stack.pop();\n            break;\n        }\n    }\n    return { stack: stack, linePos: linePos, anchorPosition: anchorPosition, isFirstLine: isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    // Look for normal grammar rule\n    const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    // Look for injected rules\n    const injections = grammar.getInjections();\n    if (injections.length === 0) {\n        // No injections whatsoever => early return\n        return matchResult;\n    }\n    const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    if (!injectionResult) {\n        // No injections matched => early return\n        return matchResult;\n    }\n    if (!matchResult) {\n        // Only injections matched => early return\n        return injectionResult;\n    }\n    // Decide if `matchResult` or `injectionResult` should win\n    const matchResultScore = matchResult.captureIndices[0].start;\n    const injectionResultScore = injectionResult.captureIndices[0].start;\n    if (injectionResultScore < matchResultScore || (injectionResult.priorityMatch && injectionResultScore === matchResultScore)) {\n        // injection won!\n        return injectionResult;\n    }\n    return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    const rule = stack.getRule(grammar);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n    let perfStart = 0;\n    if (debug_1.DebugFlags.InDebugMode) {\n        perfStart = utils_1.performanceNow();\n    }\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (debug_1.DebugFlags.InDebugMode) {\n        const elapsedMillis = utils_1.performanceNow() - perfStart;\n        if (elapsedMillis > 5) {\n            console.warn(`Rule ${rule.debugName} (${rule.id}) matching took ${elapsedMillis} against '${lineText}'`);\n        }\n        console.log(`  scanning for (linePos: ${linePos}, anchorPosition: ${anchorPosition})`);\n        console.log(ruleScanner.toString());\n        if (r) {\n            console.log(`matched rule id: ${r.ruleId} from ${r.captureIndices[0].start} to ${r.captureIndices[0].end}`);\n        }\n    }\n    if (r) {\n        return {\n            captureIndices: r.captureIndices,\n            matchedRuleId: r.ruleId\n        };\n    }\n    return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    // The lower the better\n    let bestMatchRating = Number.MAX_VALUE;\n    let bestMatchCaptureIndices = null;\n    let bestMatchRuleId;\n    let bestMatchResultPriority = 0;\n    const scopes = stack.contentNameScopesList.getScopeNames();\n    for (let i = 0, len = injections.length; i < len; i++) {\n        const injection = injections[i];\n        if (!injection.matcher(scopes)) {\n            // injection selector doesn't match stack\n            continue;\n        }\n        const rule = grammar.getRule(injection.ruleId);\n        const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n        const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n        if (!matchResult) {\n            continue;\n        }\n        if (debug_1.DebugFlags.InDebugMode) {\n            console.log(`  matched injection: ${injection.debugSelector}`);\n            console.log(ruleScanner.toString());\n        }\n        const matchRating = matchResult.captureIndices[0].start;\n        if (matchRating >= bestMatchRating) {\n            // Injections are sorted by priority, so the previous injection had a better or equal priority\n            continue;\n        }\n        bestMatchRating = matchRating;\n        bestMatchCaptureIndices = matchResult.captureIndices;\n        bestMatchRuleId = matchResult.ruleId;\n        bestMatchResultPriority = injection.priority;\n        if (bestMatchRating === linePos) {\n            // No more need to look at the rest of the injections.\n            break;\n        }\n    }\n    if (bestMatchCaptureIndices) {\n        return {\n            priorityMatch: bestMatchResultPriority === -1,\n            captureIndices: bestMatchCaptureIndices,\n            matchedRuleId: bestMatchRuleId\n        };\n    }\n    return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n    if (debug_1.UseOnigurumaFindOptions) {\n        const ruleScanner = rule.compile(grammar, endRegexSource);\n        const findOptions = getFindOptions(allowA, allowG);\n        return { ruleScanner, findOptions };\n    }\n    const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n    return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n    if (debug_1.UseOnigurumaFindOptions) {\n        const ruleScanner = rule.compileWhile(grammar, endRegexSource);\n        const findOptions = getFindOptions(allowA, allowG);\n        return { ruleScanner, findOptions };\n    }\n    const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n    return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction getFindOptions(allowA, allowG) {\n    let options = 0 /* None */;\n    if (!allowA) {\n        options |= 1 /* NotBeginString */;\n    }\n    if (!allowG) {\n        options |= 4 /* NotBeginPosition */;\n    }\n    return options;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n    if (captures.length === 0) {\n        return;\n    }\n    const lineTextContent = lineText.content;\n    const len = Math.min(captures.length, captureIndices.length);\n    const localStack = [];\n    const maxEnd = captureIndices[0].end;\n    for (let i = 0; i < len; i++) {\n        const captureRule = captures[i];\n        if (captureRule === null) {\n            // Not interested\n            continue;\n        }\n        const captureIndex = captureIndices[i];\n        if (captureIndex.length === 0) {\n            // Nothing really captured\n            continue;\n        }\n        if (captureIndex.start > maxEnd) {\n            // Capture going beyond consumed string\n            break;\n        }\n        // pop captures while needed\n        while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n            // pop!\n            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n            localStack.pop();\n        }\n        if (localStack.length > 0) {\n            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n        }\n        else {\n            lineTokens.produce(stack, captureIndex.start);\n        }\n        if (captureRule.retokenizeCapturedWithRuleId) {\n            // the capture requires additional matching\n            const scopeName = captureRule.getName(lineTextContent, captureIndices);\n            const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n            const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n            const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n            const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n            const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n            _tokenizeString(grammar, onigSubStr, (isFirstLine && captureIndex.start === 0), captureIndex.start, stackClone, lineTokens, false, /* no time limit */ 0);\n            onigLib_1.disposeOnigString(onigSubStr);\n            continue;\n        }\n        const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n        if (captureRuleScopeName !== null) {\n            // push\n            const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n            const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n            localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n        }\n    }\n    while (localStack.length > 0) {\n        // pop!\n        lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n        localStack.pop();\n    }\n}\nclass LocalStackElement {\n    constructor(scopes, endPos) {\n        this.scopes = scopes;\n        this.endPos = endPos;\n    }\n}\nexports.LocalStackElement = LocalStackElement;\n//# sourceMappingURL=tokenizeString.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJSON = void 0;\nfunction doFail(streamState, msg) {\n    // console.log('Near offset ' + streamState.pos + ': ' + msg + ' ~~~' + streamState.source.substr(streamState.pos, 50) + '~~~');\n    throw new Error('Near offset ' + streamState.pos + ': ' + msg + ' ~~~' + streamState.source.substr(streamState.pos, 50) + '~~~');\n}\nfunction parseJSON(source, filename, withMetadata) {\n    let streamState = new JSONStreamState(source);\n    let token = new JSONToken();\n    let state = 0 /* ROOT_STATE */;\n    let cur = null;\n    let stateStack = [];\n    let objStack = [];\n    function pushState() {\n        stateStack.push(state);\n        objStack.push(cur);\n    }\n    function popState() {\n        state = stateStack.pop();\n        cur = objStack.pop();\n    }\n    function fail(msg) {\n        doFail(streamState, msg);\n    }\n    while (nextJSONToken(streamState, token)) {\n        if (state === 0 /* ROOT_STATE */) {\n            if (cur !== null) {\n                fail('too many constructs in root');\n            }\n            if (token.type === 3 /* LEFT_CURLY_BRACKET */) {\n                cur = {};\n                if (withMetadata) {\n                    cur.$vscodeTextmateLocation = token.toLocation(filename);\n                }\n                pushState();\n                state = 1 /* DICT_STATE */;\n                continue;\n            }\n            if (token.type === 2 /* LEFT_SQUARE_BRACKET */) {\n                cur = [];\n                pushState();\n                state = 4 /* ARR_STATE */;\n                continue;\n            }\n            fail('unexpected token in root');\n        }\n        if (state === 2 /* DICT_STATE_COMMA */) {\n            if (token.type === 5 /* RIGHT_CURLY_BRACKET */) {\n                popState();\n                continue;\n            }\n            if (token.type === 7 /* COMMA */) {\n                state = 3 /* DICT_STATE_NO_CLOSE */;\n                continue;\n            }\n            fail('expected , or }');\n        }\n        if (state === 1 /* DICT_STATE */ || state === 3 /* DICT_STATE_NO_CLOSE */) {\n            if (state === 1 /* DICT_STATE */ && token.type === 5 /* RIGHT_CURLY_BRACKET */) {\n                popState();\n                continue;\n            }\n            if (token.type === 1 /* STRING */) {\n                let keyValue = token.value;\n                if (!nextJSONToken(streamState, token) || token.type !== 6 /* COLON */) {\n                    fail('expected colon');\n                }\n                if (!nextJSONToken(streamState, token)) {\n                    fail('expected value');\n                }\n                state = 2 /* DICT_STATE_COMMA */;\n                if (token.type === 1 /* STRING */) {\n                    cur[keyValue] = token.value;\n                    continue;\n                }\n                if (token.type === 8 /* NULL */) {\n                    cur[keyValue] = null;\n                    continue;\n                }\n                if (token.type === 9 /* TRUE */) {\n                    cur[keyValue] = true;\n                    continue;\n                }\n                if (token.type === 10 /* FALSE */) {\n                    cur[keyValue] = false;\n                    continue;\n                }\n                if (token.type === 11 /* NUMBER */) {\n                    cur[keyValue] = parseFloat(token.value);\n                    continue;\n                }\n                if (token.type === 2 /* LEFT_SQUARE_BRACKET */) {\n                    let newArr = [];\n                    cur[keyValue] = newArr;\n                    pushState();\n                    state = 4 /* ARR_STATE */;\n                    cur = newArr;\n                    continue;\n                }\n                if (token.type === 3 /* LEFT_CURLY_BRACKET */) {\n                    let newDict = {};\n                    if (withMetadata) {\n                        newDict.$vscodeTextmateLocation = token.toLocation(filename);\n                    }\n                    cur[keyValue] = newDict;\n                    pushState();\n                    state = 1 /* DICT_STATE */;\n                    cur = newDict;\n                    continue;\n                }\n            }\n            fail('unexpected token in dict');\n        }\n        if (state === 5 /* ARR_STATE_COMMA */) {\n            if (token.type === 4 /* RIGHT_SQUARE_BRACKET */) {\n                popState();\n                continue;\n            }\n            if (token.type === 7 /* COMMA */) {\n                state = 6 /* ARR_STATE_NO_CLOSE */;\n                continue;\n            }\n            fail('expected , or ]');\n        }\n        if (state === 4 /* ARR_STATE */ || state === 6 /* ARR_STATE_NO_CLOSE */) {\n            if (state === 4 /* ARR_STATE */ && token.type === 4 /* RIGHT_SQUARE_BRACKET */) {\n                popState();\n                continue;\n            }\n            state = 5 /* ARR_STATE_COMMA */;\n            if (token.type === 1 /* STRING */) {\n                cur.push(token.value);\n                continue;\n            }\n            if (token.type === 8 /* NULL */) {\n                cur.push(null);\n                continue;\n            }\n            if (token.type === 9 /* TRUE */) {\n                cur.push(true);\n                continue;\n            }\n            if (token.type === 10 /* FALSE */) {\n                cur.push(false);\n                continue;\n            }\n            if (token.type === 11 /* NUMBER */) {\n                cur.push(parseFloat(token.value));\n                continue;\n            }\n            if (token.type === 2 /* LEFT_SQUARE_BRACKET */) {\n                let newArr = [];\n                cur.push(newArr);\n                pushState();\n                state = 4 /* ARR_STATE */;\n                cur = newArr;\n                continue;\n            }\n            if (token.type === 3 /* LEFT_CURLY_BRACKET */) {\n                let newDict = {};\n                if (withMetadata) {\n                    newDict.$vscodeTextmateLocation = token.toLocation(filename);\n                }\n                cur.push(newDict);\n                pushState();\n                state = 1 /* DICT_STATE */;\n                cur = newDict;\n                continue;\n            }\n            fail('unexpected token in array');\n        }\n        fail('unknown state');\n    }\n    if (objStack.length !== 0) {\n        fail('unclosed constructs');\n    }\n    return cur;\n}\nexports.parseJSON = parseJSON;\nclass JSONStreamState {\n    constructor(source) {\n        this.source = source;\n        this.pos = 0;\n        this.len = source.length;\n        this.line = 1;\n        this.char = 0;\n    }\n}\nclass JSONToken {\n    constructor() {\n        this.value = null;\n        this.type = 0 /* UNKNOWN */;\n        this.offset = -1;\n        this.len = -1;\n        this.line = -1;\n        this.char = -1;\n    }\n    toLocation(filename) {\n        return {\n            filename: filename,\n            line: this.line,\n            char: this.char\n        };\n    }\n}\n/**\n * precondition: the string is known to be valid JSON (https://www.ietf.org/rfc/rfc4627.txt)\n */\nfunction nextJSONToken(_state, _out) {\n    _out.value = null;\n    _out.type = 0 /* UNKNOWN */;\n    _out.offset = -1;\n    _out.len = -1;\n    _out.line = -1;\n    _out.char = -1;\n    let source = _state.source;\n    let pos = _state.pos;\n    let len = _state.len;\n    let line = _state.line;\n    let char = _state.char;\n    //------------------------ skip whitespace\n    let chCode;\n    do {\n        if (pos >= len) {\n            return false; /*EOS*/\n        }\n        chCode = source.charCodeAt(pos);\n        if (chCode === 32 /* SPACE */ || chCode === 9 /* HORIZONTAL_TAB */ || chCode === 13 /* CARRIAGE_RETURN */) {\n            // regular whitespace\n            pos++;\n            char++;\n            continue;\n        }\n        if (chCode === 10 /* LINE_FEED */) {\n            // newline\n            pos++;\n            line++;\n            char = 0;\n            continue;\n        }\n        // not whitespace\n        break;\n    } while (true);\n    _out.offset = pos;\n    _out.line = line;\n    _out.char = char;\n    if (chCode === 34 /* QUOTATION_MARK */) {\n        //------------------------ strings\n        _out.type = 1 /* STRING */;\n        pos++;\n        char++;\n        do {\n            if (pos >= len) {\n                return false; /*EOS*/\n            }\n            chCode = source.charCodeAt(pos);\n            pos++;\n            char++;\n            if (chCode === 92 /* BACKSLASH */) {\n                // skip next char\n                pos++;\n                char++;\n                continue;\n            }\n            if (chCode === 34 /* QUOTATION_MARK */) {\n                // end of the string\n                break;\n            }\n        } while (true);\n        _out.value = source.substring(_out.offset + 1, pos - 1).replace(/\\\\u([0-9A-Fa-f]{4})/g, (_, m0) => {\n            return String.fromCodePoint(parseInt(m0, 16));\n        }).replace(/\\\\(.)/g, (_, m0) => {\n            switch (m0) {\n                case '\"': return '\"';\n                case '\\\\': return '\\\\';\n                case '/': return '/';\n                case 'b': return '\\b';\n                case 'f': return '\\f';\n                case 'n': return '\\n';\n                case 'r': return '\\r';\n                case 't': return '\\t';\n                default: doFail(_state, 'invalid escape sequence');\n            }\n            throw new Error('unreachable');\n        });\n    }\n    else if (chCode === 91 /* LEFT_SQUARE_BRACKET */) {\n        _out.type = 2 /* LEFT_SQUARE_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 123 /* LEFT_CURLY_BRACKET */) {\n        _out.type = 3 /* LEFT_CURLY_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 93 /* RIGHT_SQUARE_BRACKET */) {\n        _out.type = 4 /* RIGHT_SQUARE_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 125 /* RIGHT_CURLY_BRACKET */) {\n        _out.type = 5 /* RIGHT_CURLY_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 58 /* COLON */) {\n        _out.type = 6 /* COLON */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 44 /* COMMA */) {\n        _out.type = 7 /* COMMA */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 110 /* n */) {\n        //------------------------ null\n        _out.type = 8 /* NULL */;\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 117 /* u */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 108 /* l */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 108 /* l */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n    }\n    else if (chCode === 116 /* t */) {\n        //------------------------ true\n        _out.type = 9 /* TRUE */;\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 114 /* r */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 117 /* u */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 101 /* e */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n    }\n    else if (chCode === 102 /* f */) {\n        //------------------------ false\n        _out.type = 10 /* FALSE */;\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 97 /* a */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 108 /* l */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 115 /* s */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 101 /* e */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n    }\n    else {\n        //------------------------ numbers\n        _out.type = 11 /* NUMBER */;\n        do {\n            if (pos >= len) {\n                return false; /*EOS*/\n            }\n            chCode = source.charCodeAt(pos);\n            if (chCode === 46 /* DOT */\n                || (chCode >= 48 /* D0 */ && chCode <= 57 /* D9 */)\n                || (chCode === 101 /* e */ || chCode === 69 /* E */)\n                || (chCode === 45 /* MINUS */ || chCode === 43 /* PLUS */)) {\n                // looks like a piece of a number\n                pos++;\n                char++;\n                continue;\n            }\n            // pos--; char--;\n            break;\n        } while (true);\n    }\n    _out.len = pos - _out.offset;\n    if (_out.value === null) {\n        _out.value = source.substr(_out.offset, _out.len);\n    }\n    _state.pos = pos;\n    _state.line = line;\n    _state.char = char;\n    // console.log('PRODUCING TOKEN: ', _out.value, JSONTokenType[_out.type]);\n    return true;\n}\n//# sourceMappingURL=json.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseRawGrammar = exports.INITIAL = exports.Registry = void 0;\nconst grammar_1 = require(\"./grammar\");\nconst grammarReader = require(\"./parseRawGrammar\");\nconst registry_1 = require(\"./registry\");\nconst theme_1 = require(\"./theme\");\nconst grammarDependencies_1 = require(\"./grammar/grammarDependencies\");\n__exportStar(require(\"./onigLib\"), exports);\n/**\n * The registry that will hold all grammars.\n */\nclass Registry {\n    constructor(options) {\n        this._options = options;\n        this._syncRegistry = new registry_1.SyncRegistry(theme_1.Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib);\n        this._ensureGrammarCache = new Map();\n    }\n    dispose() {\n        this._syncRegistry.dispose();\n    }\n    /**\n     * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n     */\n    setTheme(theme, colorMap) {\n        this._syncRegistry.setTheme(theme_1.Theme.createFromRawTheme(theme, colorMap));\n    }\n    /**\n     * Returns a lookup array for color ids.\n     */\n    getColorMap() {\n        return this._syncRegistry.getColorMap();\n    }\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     * Please do not use language id 0.\n     */\n    loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n        return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n    }\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     * Please do not use language id 0.\n     */\n    loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n        return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new grammar_1.BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));\n    }\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     */\n    loadGrammar(initialScopeName) {\n        return this._loadGrammar(initialScopeName, 0, null, null, null);\n    }\n    async _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n        const dependencyProcessor = new grammarDependencies_1.ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n        while (dependencyProcessor.Q.length > 0) {\n            await Promise.all(dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName)));\n            dependencyProcessor.processQueue();\n        }\n        return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);\n    }\n    async _loadSingleGrammar(scopeName) {\n        if (!this._ensureGrammarCache.has(scopeName)) {\n            this._ensureGrammarCache.set(scopeName, this._doLoadSingleGrammar(scopeName));\n        }\n        return this._ensureGrammarCache.get(scopeName);\n    }\n    async _doLoadSingleGrammar(scopeName) {\n        const grammar = await this._options.loadGrammar(scopeName);\n        if (grammar) {\n            const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : undefined;\n            this._syncRegistry.addGrammar(grammar, injections);\n        }\n    }\n    /**\n     * Adds a rawGrammar.\n     */\n    async addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n        this._syncRegistry.addGrammar(rawGrammar, injections);\n        return (await this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages));\n    }\n    /**\n     * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n     */\n    _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n        return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);\n    }\n}\nexports.Registry = Registry;\nexports.INITIAL = grammar_1.StateStack.NULL;\nexports.parseRawGrammar = grammarReader.parseRawGrammar;\n//# sourceMappingURL=main.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMatchers = void 0;\nfunction createMatchers(selector, matchesName) {\n    const results = [];\n    const tokenizer = newTokenizer(selector);\n    let token = tokenizer.next();\n    while (token !== null) {\n        let priority = 0;\n        if (token.length === 2 && token.charAt(1) === ':') {\n            switch (token.charAt(0)) {\n                case 'R':\n                    priority = 1;\n                    break;\n                case 'L':\n                    priority = -1;\n                    break;\n                default:\n                    console.log(`Unknown priority ${token} in scope selector`);\n            }\n            token = tokenizer.next();\n        }\n        let matcher = parseConjunction();\n        results.push({ matcher, priority });\n        if (token !== ',') {\n            break;\n        }\n        token = tokenizer.next();\n    }\n    return results;\n    function parseOperand() {\n        if (token === '-') {\n            token = tokenizer.next();\n            const expressionToNegate = parseOperand();\n            return matcherInput => !!expressionToNegate && !expressionToNegate(matcherInput);\n        }\n        if (token === '(') {\n            token = tokenizer.next();\n            const expressionInParents = parseInnerExpression();\n            if (token === ')') {\n                token = tokenizer.next();\n            }\n            return expressionInParents;\n        }\n        if (isIdentifier(token)) {\n            const identifiers = [];\n            do {\n                identifiers.push(token);\n                token = tokenizer.next();\n            } while (isIdentifier(token));\n            return matcherInput => matchesName(identifiers, matcherInput);\n        }\n        return null;\n    }\n    function parseConjunction() {\n        const matchers = [];\n        let matcher = parseOperand();\n        while (matcher) {\n            matchers.push(matcher);\n            matcher = parseOperand();\n        }\n        return matcherInput => matchers.every(matcher => matcher(matcherInput)); // and\n    }\n    function parseInnerExpression() {\n        const matchers = [];\n        let matcher = parseConjunction();\n        while (matcher) {\n            matchers.push(matcher);\n            if (token === '|' || token === ',') {\n                do {\n                    token = tokenizer.next();\n                } while (token === '|' || token === ','); // ignore subsequent commas\n            }\n            else {\n                break;\n            }\n            matcher = parseConjunction();\n        }\n        return matcherInput => matchers.some(matcher => matcher(matcherInput)); // or\n    }\n}\nexports.createMatchers = createMatchers;\nfunction isIdentifier(token) {\n    return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n    let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n    let match = regex.exec(input);\n    return {\n        next: () => {\n            if (!match) {\n                return null;\n            }\n            const res = match[0];\n            match = regex.exec(input);\n            return res;\n        }\n    };\n}\n//# sourceMappingURL=matcher.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.disposeOnigString = void 0;\nfunction disposeOnigString(str) {\n    if (typeof str.dispose === 'function') {\n        str.dispose();\n    }\n}\nexports.disposeOnigString = disposeOnigString;\n//# sourceMappingURL=onigLib.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseRawGrammar = void 0;\nconst plist = require(\"./plist\");\nconst debug_1 = require(\"./debug\");\nconst json_1 = require(\"./json\");\nfunction parseRawGrammar(content, filePath = null) {\n    if (filePath !== null && /\\.json$/.test(filePath)) {\n        return parseJSONGrammar(content, filePath);\n    }\n    return parsePLISTGrammar(content, filePath);\n}\nexports.parseRawGrammar = parseRawGrammar;\nfunction parseJSONGrammar(contents, filename) {\n    if (debug_1.DebugFlags.InDebugMode) {\n        return json_1.parseJSON(contents, filename, true);\n    }\n    return JSON.parse(contents);\n}\nfunction parsePLISTGrammar(contents, filename) {\n    if (debug_1.DebugFlags.InDebugMode) {\n        return plist.parseWithLocation(contents, filename, '$vscodeTextmateLocation');\n    }\n    return plist.parsePLIST(contents);\n}\n//# sourceMappingURL=parseRawGrammar.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parsePLIST = exports.parseWithLocation = void 0;\nfunction parseWithLocation(content, filename, locationKeyName) {\n    return _parse(content, filename, locationKeyName);\n}\nexports.parseWithLocation = parseWithLocation;\n/**\n * A very fast plist parser\n */\nfunction parsePLIST(content) {\n    return _parse(content, null, null);\n}\nexports.parsePLIST = parsePLIST;\nfunction _parse(content, filename, locationKeyName) {\n    const len = content.length;\n    let pos = 0;\n    let line = 1;\n    let char = 0;\n    // Skip UTF8 BOM\n    if (len > 0 && content.charCodeAt(0) === 65279 /* BOM */) {\n        pos = 1;\n    }\n    function advancePosBy(by) {\n        if (locationKeyName === null) {\n            pos = pos + by;\n        }\n        else {\n            while (by > 0) {\n                let chCode = content.charCodeAt(pos);\n                if (chCode === 10 /* LINE_FEED */) {\n                    pos++;\n                    line++;\n                    char = 0;\n                }\n                else {\n                    pos++;\n                    char++;\n                }\n                by--;\n            }\n        }\n    }\n    function advancePosTo(to) {\n        if (locationKeyName === null) {\n            pos = to;\n        }\n        else {\n            advancePosBy(to - pos);\n        }\n    }\n    function skipWhitespace() {\n        while (pos < len) {\n            let chCode = content.charCodeAt(pos);\n            if (chCode !== 32 /* SPACE */ && chCode !== 9 /* TAB */ && chCode !== 13 /* CARRIAGE_RETURN */ && chCode !== 10 /* LINE_FEED */) {\n                break;\n            }\n            advancePosBy(1);\n        }\n    }\n    function advanceIfStartsWith(str) {\n        if (content.substr(pos, str.length) === str) {\n            advancePosBy(str.length);\n            return true;\n        }\n        return false;\n    }\n    function advanceUntil(str) {\n        let nextOccurence = content.indexOf(str, pos);\n        if (nextOccurence !== -1) {\n            advancePosTo(nextOccurence + str.length);\n        }\n        else {\n            // EOF\n            advancePosTo(len);\n        }\n    }\n    function captureUntil(str) {\n        let nextOccurence = content.indexOf(str, pos);\n        if (nextOccurence !== -1) {\n            let r = content.substring(pos, nextOccurence);\n            advancePosTo(nextOccurence + str.length);\n            return r;\n        }\n        else {\n            // EOF\n            let r = content.substr(pos);\n            advancePosTo(len);\n            return r;\n        }\n    }\n    let state = 0 /* ROOT_STATE */;\n    let cur = null;\n    let stateStack = [];\n    let objStack = [];\n    let curKey = null;\n    function pushState(newState, newCur) {\n        stateStack.push(state);\n        objStack.push(cur);\n        state = newState;\n        cur = newCur;\n    }\n    function popState() {\n        if (stateStack.length === 0) {\n            return fail('illegal state stack');\n        }\n        state = stateStack.pop();\n        cur = objStack.pop();\n    }\n    function fail(msg) {\n        throw new Error('Near offset ' + pos + ': ' + msg + ' ~~~' + content.substr(pos, 50) + '~~~');\n    }\n    const dictState = {\n        enterDict: function () {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            let newDict = {};\n            if (locationKeyName !== null) {\n                newDict[locationKeyName] = {\n                    filename: filename,\n                    line: line,\n                    char: char\n                };\n            }\n            cur[curKey] = newDict;\n            curKey = null;\n            pushState(1 /* DICT_STATE */, newDict);\n        },\n        enterArray: function () {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            let newArr = [];\n            cur[curKey] = newArr;\n            curKey = null;\n            pushState(2 /* ARR_STATE */, newArr);\n        }\n    };\n    const arrState = {\n        enterDict: function () {\n            let newDict = {};\n            if (locationKeyName !== null) {\n                newDict[locationKeyName] = {\n                    filename: filename,\n                    line: line,\n                    char: char\n                };\n            }\n            cur.push(newDict);\n            pushState(1 /* DICT_STATE */, newDict);\n        },\n        enterArray: function () {\n            let newArr = [];\n            cur.push(newArr);\n            pushState(2 /* ARR_STATE */, newArr);\n        }\n    };\n    function enterDict() {\n        if (state === 1 /* DICT_STATE */) {\n            dictState.enterDict();\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            arrState.enterDict();\n        }\n        else { // ROOT_STATE\n            cur = {};\n            if (locationKeyName !== null) {\n                cur[locationKeyName] = {\n                    filename: filename,\n                    line: line,\n                    char: char\n                };\n            }\n            pushState(1 /* DICT_STATE */, cur);\n        }\n    }\n    function leaveDict() {\n        if (state === 1 /* DICT_STATE */) {\n            popState();\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            return fail('unexpected </dict>');\n        }\n        else { // ROOT_STATE\n            return fail('unexpected </dict>');\n        }\n    }\n    function enterArray() {\n        if (state === 1 /* DICT_STATE */) {\n            dictState.enterArray();\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            arrState.enterArray();\n        }\n        else { // ROOT_STATE\n            cur = [];\n            pushState(2 /* ARR_STATE */, cur);\n        }\n    }\n    function leaveArray() {\n        if (state === 1 /* DICT_STATE */) {\n            return fail('unexpected </array>');\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            popState();\n        }\n        else { // ROOT_STATE\n            return fail('unexpected </array>');\n        }\n    }\n    function acceptKey(val) {\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey !== null) {\n                return fail('too many <key>');\n            }\n            curKey = val;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            return fail('unexpected <key>');\n        }\n        else { // ROOT_STATE\n            return fail('unexpected <key>');\n        }\n    }\n    function acceptString(val) {\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            cur[curKey] = val;\n            curKey = null;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            cur.push(val);\n        }\n        else { // ROOT_STATE\n            cur = val;\n        }\n    }\n    function acceptReal(val) {\n        if (isNaN(val)) {\n            return fail('cannot parse float');\n        }\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            cur[curKey] = val;\n            curKey = null;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            cur.push(val);\n        }\n        else { // ROOT_STATE\n            cur = val;\n        }\n    }\n    function acceptInteger(val) {\n        if (isNaN(val)) {\n            return fail('cannot parse integer');\n        }\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            cur[curKey] = val;\n            curKey = null;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            cur.push(val);\n        }\n        else { // ROOT_STATE\n            cur = val;\n        }\n    }\n    function acceptDate(val) {\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            cur[curKey] = val;\n            curKey = null;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            cur.push(val);\n        }\n        else { // ROOT_STATE\n            cur = val;\n        }\n    }\n    function acceptData(val) {\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            cur[curKey] = val;\n            curKey = null;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            cur.push(val);\n        }\n        else { // ROOT_STATE\n            cur = val;\n        }\n    }\n    function acceptBool(val) {\n        if (state === 1 /* DICT_STATE */) {\n            if (curKey === null) {\n                return fail('missing <key>');\n            }\n            cur[curKey] = val;\n            curKey = null;\n        }\n        else if (state === 2 /* ARR_STATE */) {\n            cur.push(val);\n        }\n        else { // ROOT_STATE\n            cur = val;\n        }\n    }\n    function escapeVal(str) {\n        return str.replace(/&#([0-9]+);/g, function (_, m0) {\n            return String.fromCodePoint(parseInt(m0, 10));\n        }).replace(/&#x([0-9a-f]+);/g, function (_, m0) {\n            return String.fromCodePoint(parseInt(m0, 16));\n        }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function (_) {\n            switch (_) {\n                case '&amp;': return '&';\n                case '&lt;': return '<';\n                case '&gt;': return '>';\n                case '&quot;': return '\"';\n                case '&apos;': return '\\'';\n            }\n            return _;\n        });\n    }\n    function parseOpenTag() {\n        let r = captureUntil('>');\n        let isClosed = false;\n        if (r.charCodeAt(r.length - 1) === 47 /* SLASH */) {\n            isClosed = true;\n            r = r.substring(0, r.length - 1);\n        }\n        return {\n            name: r.trim(),\n            isClosed: isClosed\n        };\n    }\n    function parseTagValue(tag) {\n        if (tag.isClosed) {\n            return '';\n        }\n        let val = captureUntil('</');\n        advanceUntil('>');\n        return escapeVal(val);\n    }\n    while (pos < len) {\n        skipWhitespace();\n        if (pos >= len) {\n            break;\n        }\n        const chCode = content.charCodeAt(pos);\n        advancePosBy(1);\n        if (chCode !== 60 /* LESS_THAN */) {\n            return fail('expected <');\n        }\n        if (pos >= len) {\n            return fail('unexpected end of input');\n        }\n        const peekChCode = content.charCodeAt(pos);\n        if (peekChCode === 63 /* QUESTION_MARK */) {\n            advancePosBy(1);\n            advanceUntil('?>');\n            continue;\n        }\n        if (peekChCode === 33 /* EXCLAMATION_MARK */) {\n            advancePosBy(1);\n            if (advanceIfStartsWith('--')) {\n                advanceUntil('-->');\n                continue;\n            }\n            advanceUntil('>');\n            continue;\n        }\n        if (peekChCode === 47 /* SLASH */) {\n            advancePosBy(1);\n            skipWhitespace();\n            if (advanceIfStartsWith('plist')) {\n                advanceUntil('>');\n                continue;\n            }\n            if (advanceIfStartsWith('dict')) {\n                advanceUntil('>');\n                leaveDict();\n                continue;\n            }\n            if (advanceIfStartsWith('array')) {\n                advanceUntil('>');\n                leaveArray();\n                continue;\n            }\n            return fail('unexpected closed tag');\n        }\n        let tag = parseOpenTag();\n        switch (tag.name) {\n            case 'dict':\n                enterDict();\n                if (tag.isClosed) {\n                    leaveDict();\n                }\n                continue;\n            case 'array':\n                enterArray();\n                if (tag.isClosed) {\n                    leaveArray();\n                }\n                continue;\n            case 'key':\n                acceptKey(parseTagValue(tag));\n                continue;\n            case 'string':\n                acceptString(parseTagValue(tag));\n                continue;\n            case 'real':\n                acceptReal(parseFloat(parseTagValue(tag)));\n                continue;\n            case 'integer':\n                acceptInteger(parseInt(parseTagValue(tag), 10));\n                continue;\n            case 'date':\n                acceptDate(new Date(parseTagValue(tag)));\n                continue;\n            case 'data':\n                acceptData(parseTagValue(tag));\n                continue;\n            case 'true':\n                parseTagValue(tag);\n                acceptBool(true);\n                continue;\n            case 'false':\n                parseTagValue(tag);\n                acceptBool(false);\n                continue;\n        }\n        if (/^plist/.test(tag.name)) {\n            continue;\n        }\n        return fail('unexpected opened tag ' + tag.name);\n    }\n    return cur;\n}\n//# sourceMappingURL=plist.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncRegistry = void 0;\nconst grammar_1 = require(\"./grammar\");\nclass SyncRegistry {\n    constructor(theme, _onigLibPromise) {\n        this._onigLibPromise = _onigLibPromise;\n        this._grammars = new Map();\n        this._rawGrammars = new Map();\n        this._injectionGrammars = new Map();\n        this._theme = theme;\n    }\n    dispose() {\n        for (const grammar of this._grammars.values()) {\n            grammar.dispose();\n        }\n    }\n    setTheme(theme) {\n        this._theme = theme;\n    }\n    getColorMap() {\n        return this._theme.getColorMap();\n    }\n    /**\n     * Add `grammar` to registry and return a list of referenced scope names\n     */\n    addGrammar(grammar, injectionScopeNames) {\n        this._rawGrammars.set(grammar.scopeName, grammar);\n        if (injectionScopeNames) {\n            this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n        }\n    }\n    /**\n     * Lookup a raw grammar.\n     */\n    lookup(scopeName) {\n        return this._rawGrammars.get(scopeName);\n    }\n    /**\n     * Returns the injections for the given grammar\n     */\n    injections(targetScope) {\n        return this._injectionGrammars.get(targetScope);\n    }\n    /**\n     * Get the default theme settings\n     */\n    getDefaults() {\n        return this._theme.getDefaults();\n    }\n    /**\n     * Match a scope in the theme.\n     */\n    themeMatch(scopePath) {\n        return this._theme.match(scopePath);\n    }\n    /**\n     * Lookup a grammar.\n     */\n    async grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n        if (!this._grammars.has(scopeName)) {\n            let rawGrammar = this._rawGrammars.get(scopeName);\n            if (!rawGrammar) {\n                return null;\n            }\n            this._grammars.set(scopeName, grammar_1.createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, await this._onigLibPromise));\n        }\n        return this._grammars.get(scopeName);\n    }\n}\nexports.SyncRegistry = SyncRegistry;\n//# sourceMappingURL=registry.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompiledRule = exports.RegExpSourceList = exports.RegExpSource = exports.RuleFactory = exports.BeginWhileRule = exports.BeginEndRule = exports.IncludeOnlyRule = exports.MatchRule = exports.CaptureRule = exports.Rule = exports.ruleIdToNumber = exports.ruleIdFromNumber = exports.whileRuleId = exports.endRuleId = void 0;\nconst utils_1 = require(\"./utils\");\nconst grammarDependencies_1 = require(\"./grammar/grammarDependencies\");\nconst HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nconst BACK_REFERENCING_END = /\\\\(\\d+)/g;\nconst ruleIdSymbol = Symbol('RuleId');\n// This is a special constant to indicate that the end regexp matched.\nexports.endRuleId = -1;\n// This is a special constant to indicate that the while regexp matched.\nexports.whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n    return id;\n}\nexports.ruleIdFromNumber = ruleIdFromNumber;\nfunction ruleIdToNumber(id) {\n    return id;\n}\nexports.ruleIdToNumber = ruleIdToNumber;\nclass Rule {\n    constructor($location, id, name, contentName) {\n        this.$location = $location;\n        this.id = id;\n        this._name = name || null;\n        this._nameIsCapturing = utils_1.RegexSource.hasCaptures(this._name);\n        this._contentName = contentName || null;\n        this._contentNameIsCapturing = utils_1.RegexSource.hasCaptures(this._contentName);\n    }\n    get debugName() {\n        const location = this.$location ? `${utils_1.basename(this.$location.filename)}:${this.$location.line}` : 'unknown';\n        return `${this.constructor.name}#${this.id} @ ${location}`;\n    }\n    getName(lineText, captureIndices) {\n        if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n            return this._name;\n        }\n        return utils_1.RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n    }\n    getContentName(lineText, captureIndices) {\n        if (!this._contentNameIsCapturing || this._contentName === null) {\n            return this._contentName;\n        }\n        return utils_1.RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n    }\n}\nexports.Rule = Rule;\nclass CaptureRule extends Rule {\n    constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n        super($location, id, name, contentName);\n        this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n    }\n    dispose() {\n        // nothing to dispose\n    }\n    collectPatterns(grammar, out) {\n        throw new Error('Not supported!');\n    }\n    compile(grammar, endRegexSource) {\n        throw new Error('Not supported!');\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        throw new Error('Not supported!');\n    }\n}\nexports.CaptureRule = CaptureRule;\nclass MatchRule extends Rule {\n    constructor($location, id, name, match, captures) {\n        super($location, id, name, null);\n        this._match = new RegExpSource(match, this.id);\n        this.captures = captures;\n        this._cachedCompiledPatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n    }\n    get debugMatchRegExp() {\n        return `${this._match.source}`;\n    }\n    collectPatterns(grammar, out) {\n        out.push(this._match);\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatterns(grammar, this._cachedCompiledPatterns);\n        }\n        return this._cachedCompiledPatterns;\n    }\n}\nexports.MatchRule = MatchRule;\nclass IncludeOnlyRule extends Rule {\n    constructor($location, id, name, contentName, patterns) {\n        super($location, id, name, contentName);\n        this.patterns = patterns.patterns;\n        this.hasMissingPatterns = patterns.hasMissingPatterns;\n        this._cachedCompiledPatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n    }\n    collectPatterns(grammar, out) {\n        for (const pattern of this.patterns) {\n            const rule = grammar.getRule(pattern);\n            rule.collectPatterns(grammar, out);\n        }\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatterns(grammar, this._cachedCompiledPatterns);\n        }\n        return this._cachedCompiledPatterns;\n    }\n}\nexports.IncludeOnlyRule = IncludeOnlyRule;\nclass BeginEndRule extends Rule {\n    constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n        super($location, id, name, contentName);\n        this._begin = new RegExpSource(begin, this.id);\n        this.beginCaptures = beginCaptures;\n        this._end = new RegExpSource(end ? end : '\\uFFFF', -1);\n        this.endHasBackReferences = this._end.hasBackReferences;\n        this.endCaptures = endCaptures;\n        this.applyEndPatternLast = applyEndPatternLast || false;\n        this.patterns = patterns.patterns;\n        this.hasMissingPatterns = patterns.hasMissingPatterns;\n        this._cachedCompiledPatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n    }\n    get debugBeginRegExp() {\n        return `${this._begin.source}`;\n    }\n    get debugEndRegExp() {\n        return `${this._end.source}`;\n    }\n    getEndWithResolvedBackReferences(lineText, captureIndices) {\n        return this._end.resolveBackReferences(lineText, captureIndices);\n    }\n    collectPatterns(grammar, out) {\n        out.push(this._begin);\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar, endRegexSource) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            for (const pattern of this.patterns) {\n                const rule = grammar.getRule(pattern);\n                rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n            }\n            if (this.applyEndPatternLast) {\n                this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n            }\n            else {\n                this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n            }\n        }\n        if (this._end.hasBackReferences) {\n            if (this.applyEndPatternLast) {\n                this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n            }\n            else {\n                this._cachedCompiledPatterns.setSource(0, endRegexSource);\n            }\n        }\n        return this._cachedCompiledPatterns;\n    }\n}\nexports.BeginEndRule = BeginEndRule;\nclass BeginWhileRule extends Rule {\n    constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n        super($location, id, name, contentName);\n        this._begin = new RegExpSource(begin, this.id);\n        this.beginCaptures = beginCaptures;\n        this.whileCaptures = whileCaptures;\n        this._while = new RegExpSource(_while, exports.whileRuleId);\n        this.whileHasBackReferences = this._while.hasBackReferences;\n        this.patterns = patterns.patterns;\n        this.hasMissingPatterns = patterns.hasMissingPatterns;\n        this._cachedCompiledPatterns = null;\n        this._cachedCompiledWhilePatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n        if (this._cachedCompiledWhilePatterns) {\n            this._cachedCompiledWhilePatterns.dispose();\n            this._cachedCompiledWhilePatterns = null;\n        }\n    }\n    get debugBeginRegExp() {\n        return `${this._begin.source}`;\n    }\n    get debugWhileRegExp() {\n        return `${this._while.source}`;\n    }\n    getWhileWithResolvedBackReferences(lineText, captureIndices) {\n        return this._while.resolveBackReferences(lineText, captureIndices);\n    }\n    collectPatterns(grammar, out) {\n        out.push(this._begin);\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            for (const pattern of this.patterns) {\n                const rule = grammar.getRule(pattern);\n                rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n            }\n        }\n        return this._cachedCompiledPatterns;\n    }\n    compileWhile(grammar, endRegexSource) {\n        return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n    }\n    compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n        if (!this._cachedCompiledWhilePatterns) {\n            this._cachedCompiledWhilePatterns = new RegExpSourceList();\n            this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n        }\n        if (this._while.hasBackReferences) {\n            this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : '\\uFFFF');\n        }\n        return this._cachedCompiledWhilePatterns;\n    }\n}\nexports.BeginWhileRule = BeginWhileRule;\nclass RuleFactory {\n    static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n        return helper.registerRule((id) => {\n            return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n        });\n    }\n    static getCompiledRuleId(desc, helper, repository) {\n        if (!desc.id) {\n            helper.registerRule((id) => {\n                desc.id = id;\n                if (desc.match) {\n                    return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, RuleFactory._compileCaptures(desc.captures, helper, repository));\n                }\n                if (typeof desc.begin === 'undefined') {\n                    if (desc.repository) {\n                        repository = utils_1.mergeObjects({}, repository, desc.repository);\n                    }\n                    let patterns = desc.patterns;\n                    if (typeof patterns === 'undefined' && desc.include) {\n                        patterns = [{ include: desc.include }];\n                    }\n                    return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, RuleFactory._compilePatterns(patterns, helper, repository));\n                }\n                if (desc.while) {\n                    return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), RuleFactory._compilePatterns(desc.patterns, helper, repository));\n                }\n                return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, RuleFactory._compilePatterns(desc.patterns, helper, repository));\n            });\n        }\n        return desc.id;\n    }\n    static _compileCaptures(captures, helper, repository) {\n        let r = [];\n        if (captures) {\n            // Find the maximum capture id\n            let maximumCaptureId = 0;\n            for (const captureId in captures) {\n                if (captureId === '$vscodeTextmateLocation') {\n                    continue;\n                }\n                const numericCaptureId = parseInt(captureId, 10);\n                if (numericCaptureId > maximumCaptureId) {\n                    maximumCaptureId = numericCaptureId;\n                }\n            }\n            // Initialize result\n            for (let i = 0; i <= maximumCaptureId; i++) {\n                r[i] = null;\n            }\n            // Fill out result\n            for (const captureId in captures) {\n                if (captureId === '$vscodeTextmateLocation') {\n                    continue;\n                }\n                const numericCaptureId = parseInt(captureId, 10);\n                let retokenizeCapturedWithRuleId = 0;\n                if (captures[captureId].patterns) {\n                    retokenizeCapturedWithRuleId = RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n                }\n                r[numericCaptureId] = RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n            }\n        }\n        return r;\n    }\n    static _compilePatterns(patterns, helper, repository) {\n        let r = [];\n        if (patterns) {\n            for (let i = 0, len = patterns.length; i < len; i++) {\n                const pattern = patterns[i];\n                let ruleId = -1;\n                if (pattern.include) {\n                    const reference = grammarDependencies_1.parseInclude(pattern.include);\n                    switch (reference.kind) {\n                        case 0 /* Base */:\n                        case 1 /* Self */:\n                            ruleId = RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n                            break;\n                        case 2 /* RelativeReference */:\n                            // Local include found in `repository`\n                            let localIncludedRule = repository[reference.ruleName];\n                            if (localIncludedRule) {\n                                ruleId = RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n                            }\n                            else {\n                                // console.warn('CANNOT find rule for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n                            }\n                            break;\n                        case 3 /* TopLevelReference */:\n                        case 4 /* TopLevelRepositoryReference */:\n                            const externalGrammarName = reference.scopeName;\n                            const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */\n                                ? reference.ruleName\n                                : null;\n                            // External include\n                            const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n                            if (externalGrammar) {\n                                if (externalGrammarInclude) {\n                                    let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                                    if (externalIncludedRule) {\n                                        ruleId = RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                                    }\n                                    else {\n                                        // console.warn('CANNOT find rule for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n                                    }\n                                }\n                                else {\n                                    ruleId = RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                                }\n                            }\n                            else {\n                                // console.warn('CANNOT find grammar for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n                            }\n                            break;\n                    }\n                }\n                else {\n                    ruleId = RuleFactory.getCompiledRuleId(pattern, helper, repository);\n                }\n                if (ruleId !== -1) {\n                    const rule = helper.getRule(ruleId);\n                    let skipRule = false;\n                    if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n                        if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n                            skipRule = true;\n                        }\n                    }\n                    if (skipRule) {\n                        // console.log('REMOVING RULE ENTIRELY DUE TO EMPTY PATTERNS THAT ARE MISSING');\n                        continue;\n                    }\n                    r.push(ruleId);\n                }\n            }\n        }\n        return {\n            patterns: r,\n            hasMissingPatterns: ((patterns ? patterns.length : 0) !== r.length)\n        };\n    }\n}\nexports.RuleFactory = RuleFactory;\nclass RegExpSource {\n    constructor(regExpSource, ruleId) {\n        if (regExpSource) {\n            const len = regExpSource.length;\n            let lastPushedPos = 0;\n            let output = [];\n            let hasAnchor = false;\n            for (let pos = 0; pos < len; pos++) {\n                const ch = regExpSource.charAt(pos);\n                if (ch === '\\\\') {\n                    if (pos + 1 < len) {\n                        const nextCh = regExpSource.charAt(pos + 1);\n                        if (nextCh === 'z') {\n                            output.push(regExpSource.substring(lastPushedPos, pos));\n                            output.push('$(?!\\\\n)(?<!\\\\n)');\n                            lastPushedPos = pos + 2;\n                        }\n                        else if (nextCh === 'A' || nextCh === 'G') {\n                            hasAnchor = true;\n                        }\n                        pos++;\n                    }\n                }\n            }\n            this.hasAnchor = hasAnchor;\n            if (lastPushedPos === 0) {\n                // No \\z hit\n                this.source = regExpSource;\n            }\n            else {\n                output.push(regExpSource.substring(lastPushedPos, len));\n                this.source = output.join('');\n            }\n        }\n        else {\n            this.hasAnchor = false;\n            this.source = regExpSource;\n        }\n        if (this.hasAnchor) {\n            this._anchorCache = this._buildAnchorCache();\n        }\n        else {\n            this._anchorCache = null;\n        }\n        this.ruleId = ruleId;\n        this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n        // console.log('input: ' + regExpSource + ' => ' + this.source + ', ' + this.hasAnchor);\n    }\n    clone() {\n        return new RegExpSource(this.source, this.ruleId);\n    }\n    setSource(newSource) {\n        if (this.source === newSource) {\n            return;\n        }\n        this.source = newSource;\n        if (this.hasAnchor) {\n            this._anchorCache = this._buildAnchorCache();\n        }\n    }\n    resolveBackReferences(lineText, captureIndices) {\n        let capturedValues = captureIndices.map((capture) => {\n            return lineText.substring(capture.start, capture.end);\n        });\n        BACK_REFERENCING_END.lastIndex = 0;\n        return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n            return utils_1.escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || '');\n        });\n    }\n    _buildAnchorCache() {\n        let A0_G0_result = [];\n        let A0_G1_result = [];\n        let A1_G0_result = [];\n        let A1_G1_result = [];\n        let pos, len, ch, nextCh;\n        for (pos = 0, len = this.source.length; pos < len; pos++) {\n            ch = this.source.charAt(pos);\n            A0_G0_result[pos] = ch;\n            A0_G1_result[pos] = ch;\n            A1_G0_result[pos] = ch;\n            A1_G1_result[pos] = ch;\n            if (ch === '\\\\') {\n                if (pos + 1 < len) {\n                    nextCh = this.source.charAt(pos + 1);\n                    if (nextCh === 'A') {\n                        A0_G0_result[pos + 1] = '\\uFFFF';\n                        A0_G1_result[pos + 1] = '\\uFFFF';\n                        A1_G0_result[pos + 1] = 'A';\n                        A1_G1_result[pos + 1] = 'A';\n                    }\n                    else if (nextCh === 'G') {\n                        A0_G0_result[pos + 1] = '\\uFFFF';\n                        A0_G1_result[pos + 1] = 'G';\n                        A1_G0_result[pos + 1] = '\\uFFFF';\n                        A1_G1_result[pos + 1] = 'G';\n                    }\n                    else {\n                        A0_G0_result[pos + 1] = nextCh;\n                        A0_G1_result[pos + 1] = nextCh;\n                        A1_G0_result[pos + 1] = nextCh;\n                        A1_G1_result[pos + 1] = nextCh;\n                    }\n                    pos++;\n                }\n            }\n        }\n        return {\n            A0_G0: A0_G0_result.join(''),\n            A0_G1: A0_G1_result.join(''),\n            A1_G0: A1_G0_result.join(''),\n            A1_G1: A1_G1_result.join('')\n        };\n    }\n    resolveAnchors(allowA, allowG) {\n        if (!this.hasAnchor || !this._anchorCache) {\n            return this.source;\n        }\n        if (allowA) {\n            if (allowG) {\n                return this._anchorCache.A1_G1;\n            }\n            else {\n                return this._anchorCache.A1_G0;\n            }\n        }\n        else {\n            if (allowG) {\n                return this._anchorCache.A0_G1;\n            }\n            else {\n                return this._anchorCache.A0_G0;\n            }\n        }\n    }\n}\nexports.RegExpSource = RegExpSource;\nclass RegExpSourceList {\n    constructor() {\n        this._items = [];\n        this._hasAnchors = false;\n        this._cached = null;\n        this._anchorCache = {\n            A0_G0: null,\n            A0_G1: null,\n            A1_G0: null,\n            A1_G1: null\n        };\n    }\n    dispose() {\n        this._disposeCaches();\n    }\n    _disposeCaches() {\n        if (this._cached) {\n            this._cached.dispose();\n            this._cached = null;\n        }\n        if (this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0.dispose();\n            this._anchorCache.A0_G0 = null;\n        }\n        if (this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1.dispose();\n            this._anchorCache.A0_G1 = null;\n        }\n        if (this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0.dispose();\n            this._anchorCache.A1_G0 = null;\n        }\n        if (this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1.dispose();\n            this._anchorCache.A1_G1 = null;\n        }\n    }\n    push(item) {\n        this._items.push(item);\n        this._hasAnchors = this._hasAnchors || item.hasAnchor;\n    }\n    unshift(item) {\n        this._items.unshift(item);\n        this._hasAnchors = this._hasAnchors || item.hasAnchor;\n    }\n    length() {\n        return this._items.length;\n    }\n    setSource(index, newSource) {\n        if (this._items[index].source !== newSource) {\n            // bust the cache\n            this._disposeCaches();\n            this._items[index].setSource(newSource);\n        }\n    }\n    compile(onigLib) {\n        if (!this._cached) {\n            let regExps = this._items.map(e => e.source);\n            this._cached = new CompiledRule(onigLib, regExps, this._items.map(e => e.ruleId));\n        }\n        return this._cached;\n    }\n    compileAG(onigLib, allowA, allowG) {\n        if (!this._hasAnchors) {\n            return this.compile(onigLib);\n        }\n        else {\n            if (allowA) {\n                if (allowG) {\n                    if (!this._anchorCache.A1_G1) {\n                        this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A1_G1;\n                }\n                else {\n                    if (!this._anchorCache.A1_G0) {\n                        this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A1_G0;\n                }\n            }\n            else {\n                if (allowG) {\n                    if (!this._anchorCache.A0_G1) {\n                        this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A0_G1;\n                }\n                else {\n                    if (!this._anchorCache.A0_G0) {\n                        this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A0_G0;\n                }\n            }\n        }\n    }\n    _resolveAnchors(onigLib, allowA, allowG) {\n        let regExps = this._items.map(e => e.resolveAnchors(allowA, allowG));\n        return new CompiledRule(onigLib, regExps, this._items.map(e => e.ruleId));\n    }\n}\nexports.RegExpSourceList = RegExpSourceList;\nclass CompiledRule {\n    constructor(onigLib, regExps, rules) {\n        this.regExps = regExps;\n        this.rules = rules;\n        this.scanner = onigLib.createOnigScanner(regExps);\n    }\n    dispose() {\n        if (typeof this.scanner.dispose === \"function\") {\n            this.scanner.dispose();\n        }\n    }\n    toString() {\n        const r = [];\n        for (let i = 0, len = this.rules.length; i < len; i++) {\n            r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n        }\n        return r.join(\"\\n\");\n    }\n    findNextMatchSync(string, startPosition, options) {\n        const result = this.scanner.findNextMatchSync(string, startPosition, options);\n        if (!result) {\n            return null;\n        }\n        return {\n            ruleId: this.rules[result.index],\n            captureIndices: result.captureIndices,\n        };\n    }\n}\nexports.CompiledRule = CompiledRule;\n//# sourceMappingURL=rule.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThemeTrieElement = exports.ThemeTrieElementRule = exports.ColorMap = exports.fontStyleToString = exports.ParsedThemeRule = exports.parseTheme = exports.StyleAttributes = exports.ScopeStack = exports.Theme = void 0;\nconst utils_1 = require(\"./utils\");\nclass Theme {\n    constructor(_colorMap, _defaults, _root) {\n        this._colorMap = _colorMap;\n        this._defaults = _defaults;\n        this._root = _root;\n        this._cachedMatchRoot = new utils_1.CachedFn((scopeName) => this._root.match(scopeName));\n    }\n    static createFromRawTheme(source, colorMap) {\n        return this.createFromParsedTheme(parseTheme(source), colorMap);\n    }\n    static createFromParsedTheme(source, colorMap) {\n        return resolveParsedThemeRules(source, colorMap);\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    getDefaults() {\n        return this._defaults;\n    }\n    match(scopePath) {\n        if (scopePath === null) {\n            return this._defaults;\n        }\n        const scopeName = scopePath.scopeName;\n        const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n        const effectiveRule = matchingTrieElements.find((v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));\n        if (!effectiveRule) {\n            return null;\n        }\n        return new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background);\n    }\n}\nexports.Theme = Theme;\nclass ScopeStack {\n    constructor(parent, scopeName) {\n        this.parent = parent;\n        this.scopeName = scopeName;\n    }\n    static from(...segments) {\n        let result = null;\n        for (let i = 0; i < segments.length; i++) {\n            result = new ScopeStack(result, segments[i]);\n        }\n        return result;\n    }\n    push(scopeName) {\n        return new ScopeStack(this, scopeName);\n    }\n    getSegments() {\n        let item = this;\n        const result = [];\n        while (item) {\n            result.push(item.scopeName);\n            item = item.parent;\n        }\n        result.reverse();\n        return result;\n    }\n    toString() {\n        return this.getSegments().join(' ');\n    }\n}\nexports.ScopeStack = ScopeStack;\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n    if (parentScopes === null) {\n        return true;\n    }\n    let index = 0;\n    let scopePattern = parentScopes[index];\n    while (scopePath) {\n        if (_matchesScope(scopePath.scopeName, scopePattern)) {\n            index++;\n            if (index === parentScopes.length) {\n                return true;\n            }\n            scopePattern = parentScopes[index];\n        }\n        scopePath = scopePath.parent;\n    }\n    return false;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n    return scopePattern === scopeName || (scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === '.');\n}\nclass StyleAttributes {\n    constructor(fontStyle, foregroundId, backgroundId) {\n        this.fontStyle = fontStyle;\n        this.foregroundId = foregroundId;\n        this.backgroundId = backgroundId;\n    }\n}\nexports.StyleAttributes = StyleAttributes;\n/**\n * Parse a raw theme into rules.\n */\nfunction parseTheme(source) {\n    if (!source) {\n        return [];\n    }\n    if (!source.settings || !Array.isArray(source.settings)) {\n        return [];\n    }\n    let settings = source.settings;\n    let result = [], resultLen = 0;\n    for (let i = 0, len = settings.length; i < len; i++) {\n        let entry = settings[i];\n        if (!entry.settings) {\n            continue;\n        }\n        let scopes;\n        if (typeof entry.scope === 'string') {\n            let _scope = entry.scope;\n            // remove leading commas\n            _scope = _scope.replace(/^[,]+/, '');\n            // remove trailing commans\n            _scope = _scope.replace(/[,]+$/, '');\n            scopes = _scope.split(',');\n        }\n        else if (Array.isArray(entry.scope)) {\n            scopes = entry.scope;\n        }\n        else {\n            scopes = [''];\n        }\n        let fontStyle = -1 /* NotSet */;\n        if (typeof entry.settings.fontStyle === 'string') {\n            fontStyle = 0 /* None */;\n            let segments = entry.settings.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                let segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.settings.foreground === 'string' && utils_1.isValidHexColor(entry.settings.foreground)) {\n            foreground = entry.settings.foreground;\n        }\n        let background = null;\n        if (typeof entry.settings.background === 'string' && utils_1.isValidHexColor(entry.settings.background)) {\n            background = entry.settings.background;\n        }\n        for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n            let _scope = scopes[j].trim();\n            let segments = _scope.split(' ');\n            let scope = segments[segments.length - 1];\n            let parentScopes = null;\n            if (segments.length > 1) {\n                parentScopes = segments.slice(0, segments.length - 1);\n                parentScopes.reverse();\n            }\n            result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);\n        }\n    }\n    return result;\n}\nexports.parseTheme = parseTheme;\nclass ParsedThemeRule {\n    constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n        this.scope = scope;\n        this.parentScopes = parentScopes;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\nexports.ParsedThemeRule = ParsedThemeRule;\nfunction fontStyleToString(fontStyle) {\n    if (fontStyle === -1 /* NotSet */) {\n        return 'not set';\n    }\n    let style = '';\n    if (fontStyle & 1 /* Italic */) {\n        style += 'italic ';\n    }\n    if (fontStyle & 2 /* Bold */) {\n        style += 'bold ';\n    }\n    if (fontStyle & 4 /* Underline */) {\n        style += 'underline ';\n    }\n    if (fontStyle & 8 /* Strikethrough */) {\n        style += 'strikethrough ';\n    }\n    if (style === '') {\n        style = 'none';\n    }\n    return style.trim();\n}\nexports.fontStyleToString = fontStyleToString;\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        let r = utils_1.strcmp(a.scope, b.scope);\n        if (r !== 0) {\n            return r;\n        }\n        r = utils_1.strArrCmp(a.parentScopes, b.parentScopes);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* None */;\n    let defaultForeground = '#000000';\n    let defaultBackground = '#ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === '') {\n        let incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    let colorMap = new ColorMap(_colorMap);\n    let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n    let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        let rule = parsedThemeRules[i];\n        root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new Theme(colorMap, defaults, root);\n}\nclass ColorMap {\n    constructor(_colorMap) {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = Object.create(null);\n        if (Array.isArray(_colorMap)) {\n            this._isFrozen = true;\n            for (let i = 0, len = _colorMap.length; i < len; i++) {\n                this._color2id[_colorMap[i]] = i;\n                this._id2color[i] = _colorMap[i];\n            }\n        }\n        else {\n            this._isFrozen = false;\n        }\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        color = color.toUpperCase();\n        let value = this._color2id[color];\n        if (value) {\n            return value;\n        }\n        if (this._isFrozen) {\n            throw new Error(`Missing color in color map - ${color}`);\n        }\n        value = ++this._lastColorId;\n        this._color2id[color] = value;\n        this._id2color[value] = color;\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexports.ColorMap = ColorMap;\nclass ThemeTrieElementRule {\n    constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n        this.scopeDepth = scopeDepth;\n        this.parentScopes = parentScopes;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n    }\n    static cloneArr(arr) {\n        let r = [];\n        for (let i = 0, len = arr.length; i < len; i++) {\n            r[i] = arr[i].clone();\n        }\n        return r;\n    }\n    acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n        if (this.scopeDepth > scopeDepth) {\n            console.log('how did this happen?');\n        }\n        else {\n            this.scopeDepth = scopeDepth;\n        }\n        // console.log('TODO -> my depth: ' + this.scopeDepth + ', overwriting depth: ' + scopeDepth);\n        if (fontStyle !== -1 /* NotSet */) {\n            this.fontStyle = fontStyle;\n        }\n        if (foreground !== 0) {\n            this.foreground = foreground;\n        }\n        if (background !== 0) {\n            this.background = background;\n        }\n    }\n}\nexports.ThemeTrieElementRule = ThemeTrieElementRule;\nclass ThemeTrieElement {\n    constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n        this._mainRule = _mainRule;\n        this._children = _children;\n        this._rulesWithParentScopes = rulesWithParentScopes;\n    }\n    static _sortBySpecificity(arr) {\n        if (arr.length === 1) {\n            return arr;\n        }\n        arr.sort(this._cmpBySpecificity);\n        return arr;\n    }\n    static _cmpBySpecificity(a, b) {\n        if (a.scopeDepth === b.scopeDepth) {\n            const aParentScopes = a.parentScopes;\n            const bParentScopes = b.parentScopes;\n            let aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;\n            let bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;\n            if (aParentScopesLen === bParentScopesLen) {\n                for (let i = 0; i < aParentScopesLen; i++) {\n                    const aLen = aParentScopes[i].length;\n                    const bLen = bParentScopes[i].length;\n                    if (aLen !== bLen) {\n                        return bLen - aLen;\n                    }\n                }\n            }\n            return bParentScopesLen - aParentScopesLen;\n        }\n        return b.scopeDepth - a.scopeDepth;\n    }\n    match(scope) {\n        if (scope === '') {\n            return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n        }\n        let dotIndex = scope.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = scope;\n            tail = '';\n        }\n        else {\n            head = scope.substring(0, dotIndex);\n            tail = scope.substring(dotIndex + 1);\n        }\n        if (this._children.hasOwnProperty(head)) {\n            return this._children[head].match(tail);\n        }\n        return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n    }\n    insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n        if (scope === '') {\n            this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n            return;\n        }\n        let dotIndex = scope.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = scope;\n            tail = '';\n        }\n        else {\n            head = scope.substring(0, dotIndex);\n            tail = scope.substring(dotIndex + 1);\n        }\n        let child;\n        if (this._children.hasOwnProperty(head)) {\n            child = this._children[head];\n        }\n        else {\n            child = new ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n            this._children[head] = child;\n        }\n        child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n    }\n    _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n        if (parentScopes === null) {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n            return;\n        }\n        // Try to merge into existing rule\n        for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n            let rule = this._rulesWithParentScopes[i];\n            if (utils_1.strArrCmp(rule.parentScopes, parentScopes) === 0) {\n                // bingo! => we get to merge this into an existing one\n                rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n                return;\n            }\n        }\n        // Must add a new rule\n        // Inherit from main rule\n        if (fontStyle === -1 /* NotSet */) {\n            fontStyle = this._mainRule.fontStyle;\n        }\n        if (foreground === 0) {\n            foreground = this._mainRule.foreground;\n        }\n        if (background === 0) {\n            background = this._mainRule.background;\n        }\n        this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n    }\n}\nexports.ThemeTrieElement = ThemeTrieElement;\n//# sourceMappingURL=theme.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.performanceNow = exports.CachedFn = exports.escapeRegExpCharacters = exports.isValidHexColor = exports.strArrCmp = exports.strcmp = exports.RegexSource = exports.basename = exports.mergeObjects = exports.clone = void 0;\nfunction clone(something) {\n    return doClone(something);\n}\nexports.clone = clone;\nfunction doClone(something) {\n    if (Array.isArray(something)) {\n        return cloneArray(something);\n    }\n    if (typeof something === 'object') {\n        return cloneObj(something);\n    }\n    return something;\n}\nfunction cloneArray(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        r[i] = doClone(arr[i]);\n    }\n    return r;\n}\nfunction cloneObj(obj) {\n    let r = {};\n    for (let key in obj) {\n        r[key] = doClone(obj[key]);\n    }\n    return r;\n}\nfunction mergeObjects(target, ...sources) {\n    sources.forEach(source => {\n        for (let key in source) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n}\nexports.mergeObjects = mergeObjects;\nfunction basename(path) {\n    const idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\\\');\n    if (idx === 0) {\n        return path;\n    }\n    else if (~idx === path.length - 1) {\n        return basename(path.substring(0, path.length - 1));\n    }\n    else {\n        return path.substr(~idx + 1);\n    }\n}\nexports.basename = basename;\nlet CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nclass RegexSource {\n    static hasCaptures(regexSource) {\n        if (regexSource === null) {\n            return false;\n        }\n        CAPTURING_REGEX_SOURCE.lastIndex = 0;\n        return CAPTURING_REGEX_SOURCE.test(regexSource);\n    }\n    static replaceCaptures(regexSource, captureSource, captureIndices) {\n        return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n            let capture = captureIndices[parseInt(index || commandIndex, 10)];\n            if (capture) {\n                let result = captureSource.substring(capture.start, capture.end);\n                // Remove leading dots that would make the selector invalid\n                while (result[0] === '.') {\n                    result = result.substring(1);\n                }\n                switch (command) {\n                    case 'downcase':\n                        return result.toLowerCase();\n                    case 'upcase':\n                        return result.toUpperCase();\n                    default:\n                        return result;\n                }\n            }\n            else {\n                return match;\n            }\n        });\n    }\n}\nexports.RegexSource = RegexSource;\nfunction strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexports.strcmp = strcmp;\nfunction strArrCmp(a, b) {\n    if (a === null && b === null) {\n        return 0;\n    }\n    if (!a) {\n        return -1;\n    }\n    if (!b) {\n        return 1;\n    }\n    let len1 = a.length;\n    let len2 = b.length;\n    if (len1 === len2) {\n        for (let i = 0; i < len1; i++) {\n            let res = strcmp(a[i], b[i]);\n            if (res !== 0) {\n                return res;\n            }\n        }\n        return 0;\n    }\n    return len1 - len2;\n}\nexports.strArrCmp = strArrCmp;\nfunction isValidHexColor(hex) {\n    if (/^#[0-9a-f]{6}$/i.test(hex)) {\n        // #rrggbb\n        return true;\n    }\n    if (/^#[0-9a-f]{8}$/i.test(hex)) {\n        // #rrggbbaa\n        return true;\n    }\n    if (/^#[0-9a-f]{3}$/i.test(hex)) {\n        // #rgb\n        return true;\n    }\n    if (/^#[0-9a-f]{4}$/i.test(hex)) {\n        // #rgba\n        return true;\n    }\n    return false;\n}\nexports.isValidHexColor = isValidHexColor;\n/**\n * Escapes regular expression characters in a given string\n */\nfunction escapeRegExpCharacters(value) {\n    return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n}\nexports.escapeRegExpCharacters = escapeRegExpCharacters;\nclass CachedFn {\n    constructor(fn) {\n        this.fn = fn;\n        this.cache = new Map();\n    }\n    get(key) {\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        const value = this.fn(key);\n        this.cache.set(key, value);\n        return value;\n    }\n}\nexports.CachedFn = CachedFn;\nexports.performanceNow = typeof performance === \"undefined\"\n    // performance.now() is not available in this environment, so use Date.now()\n    ? function () {\n        return Date.now();\n    }\n    : function () {\n        return performance.now();\n    };\n//# sourceMappingURL=utils.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(787);\n"],"names":["root","factory","exports","module","define","amd","this","Object","defineProperty","value","UseOnigurumaFindOptions","DebugFlags","InDebugMode","process","env","EncodedTokenAttributes","toOptionalTokenType","toBinaryStr","encodedTokenAttributes","r","toString","length","print","languageId","getLanguageId","tokenType","getTokenType","fontStyle","getFontStyle","foreground","getForeground","background","getBackground","console","log","containsBalancedBrackets","set","_languageId","_tokenType","_containsBalancedBracketsBit","_fontStyle","_foreground","_background","standardType","BasicScopeAttributesProvider","BasicScopeAttributes","utils_1","constructor","initialLanguageId","embeddedLanguages","_getBasicScopeAttributes","CachedFn","scopeName","_scopeToLanguage","standardTokenType","_toStandardTokenType","_defaultAttributes","_embeddedLanguagesMatcher","ScopeMatcher","entries","getDefaultAttributes","getBasicScopeAttributes","_NULL_SCOPE_METADATA","get","scope","match","m","STANDARD_TOKEN_TYPE_REGEXP","Error","values","scopesRegExp","Map","escapedScopes","map","escapeRegExpCharacters","sort","reverse","RegExp","join","LineTokens","BalancedBracketSelectors","StateStack","AttributedScopeStack","Grammar","createGrammar","debug_1","encodedTokenAttributes_1","matcher_1","onigLib_1","rule_1","theme_1","basicScopesAttributeProvider_1","tokenizeString_1","collectInjections","result","selector","rule","ruleFactoryHelper","grammar","matchers","createMatchers","nameMatcher","ruleId","RuleFactory","getCompiledRuleId","repository","matcher","push","debugSelector","priority","identifers","scopes","lastIndex","every","identifier","i","scopesAreMatching","thisScopeName","len","substr","initialLanguage","tokenTypes","balancedBracketSelectors","grammarRepository","onigLib","_rootScopeName","_onigLib","_basicScopeAttributesProvider","_rootId","_lastRuleId","_ruleId2desc","_includedGrammars","_grammarRepository","_grammar","initGrammar","_injections","_tokenTypeMatchers","keys","type","themeProvider","dispose","createOnigScanner","sources","createOnigString","getMetadataForScope","_collectInjections","getExternalGrammar","rawInjections","injections","expression","injectionScopeNames","forEach","injectionScopeName","injectionGrammar","injectionSelector","i1","i2","getInjections","injection","registerRule","id","ruleIdFromNumber","getRule","ruleIdToNumber","rawIncludedGrammar","lookup","$base","tokenizeLine","lineText","prevState","timeLimit","_tokenize","tokens","lineTokens","getResult","ruleStack","lineLength","stoppedEarly","tokenizeLine2","getBinaryResult","emitBinaryTokens","isFirstLine","$self","NULL","reset","rawDefaultMetadata","defaultStyle","getDefaults","defaultMetadata","foregroundId","backgroundId","rootScopeName","getName","scopeList","createRootAndLookUpScopeName","createRoot","onigLineText","content","_tokenizeString","disposeOnigString","stack","base","clone","$vscodeTextmateLocation","patterns","name","parent","scopePath","tokenAttributes","static","ScopeStack","rawRootMetadata","rootStyle","themeMatch","resolvedTokenAttributes","mergeAttributes","equals","other","_equals","a","b","existingTokenAttributes","basicScopeAttributes","styleAttributes","pushAttributed","indexOf","_pushAttributed","split","target","rawMetadata","newPath","scopeThemeMatchResult","metadata","getScopeNames","getSegments","enterPos","anchorPos","beginRuleCapturedEOL","endRule","nameScopesList","contentNameScopesList","_stackElementBrand","undefined","depth","_enterPos","_anchorPos","_structuralEquals","el","_reset","pop","safePop","getEnterPos","getAnchorPos","_writeString","res","outIndex","withContentNameScopesList","contentNameScopeStack","withEndRule","hasSameRuleAs","balancedBracketScopes","unbalancedBracketScopes","allowAny","flatMap","matchesAlways","matchesNever","excluder","includer","tokenTypeOverrides","_emitBinaryTokens","_tokenTypeOverrides","_lineText","_tokens","_binaryTokens","_lastTokenEndIndex","produce","endIndex","produceFromScopes","scopesList","substring","replace","k","startIndex","Uint32Array","parseInclude","TopLevelRepositoryReference","TopLevelReference","RelativeReference","SelfReference","BaseReference","ScopeDependencyProcessor","ExternalReferenceCollector","TopLevelRepositoryRuleReference","TopLevelRuleReference","toKey","ruleName","_references","_seenReferenceKeys","Set","visitedRule","references","add","reference","key","has","collectReferencesOfReference","baseGrammarScopeName","repo","selfGrammar","baseGrammar","collectExternalReferencesInTopLevelRule","collectExternalReferencesInTopLevelRepositoryRule","context","collectExternalReferencesInRules","Array","isArray","rules","patternRepository","mergeObjects","include","kind","newContext","initialScopeName","seenFullScopeRequests","seenPartialScopeRequests","Q","processQueue","q","deps","dep","indexOfSharp","__createBinding","create","o","k2","enumerable","__exportStar","p","prototype","hasOwnProperty","call","LocalStackElement","TokenizeStringResult","linePos","checkWhileConditions","STOP","anchorPosition","whileCheckResult","whileRules","node","nodeRule","BeginWhileRule","whileRule","ruleScanner","findOptions","prepareRuleWhileSearch","findNextMatchSync","debugName","debugWhileRegExp","whileRuleId","captureIndices","start","handleCaptures","whileCaptures","end","_checkWhileConditions","startTime","Date","now","scanNext","matchResult","prepareRuleSearch","perfStart","performanceNow","elapsedMillis","warn","matchedRuleId","matchRule","injectionResult","bestMatchRuleId","bestMatchRating","Number","MAX_VALUE","bestMatchCaptureIndices","bestMatchResultPriority","matchRating","priorityMatch","matchInjections","matchResultScore","injectionResultScore","matchRuleOrInjections","hasAdvanced","endRuleId","poppedRule","debugEndRegExp","endCaptures","popped","error","_rule","beforePush","BeginEndRule","pushedRule","debugBeginRegExp","beginCaptures","contentName","getContentName","endHasBackReferences","getEndWithResolvedBackReferences","whileHasBackReferences","getWhileWithResolvedBackReferences","matchingRule","debugMatchRegExp","captures","endRegexSource","allowA","allowG","compile","getFindOptions","compileAG","compileWhile","compileWhileAG","options","lineTextContent","Math","min","localStack","maxEnd","captureRule","captureIndex","endPos","retokenizeCapturedWithRuleId","stackClone","onigSubStr","captureRuleScopeName","captureRuleScopesList","doFail","streamState","msg","pos","source","parseJSON","filename","withMetadata","JSONStreamState","token","JSONToken","state","cur","stateStack","objStack","pushState","popState","fail","nextJSONToken","toLocation","keyValue","parseFloat","newArr","newDict","line","char","offset","_state","_out","chCode","charCodeAt","_","m0","String","fromCodePoint","parseInt","parseRawGrammar","INITIAL","Registry","grammar_1","grammarReader","registry_1","grammarDependencies_1","_options","_syncRegistry","SyncRegistry","Theme","createFromRawTheme","theme","colorMap","_ensureGrammarCache","setTheme","getColorMap","loadGrammarWithEmbeddedLanguages","loadGrammarWithConfiguration","configuration","_loadGrammar","unbalancedBracketSelectors","loadGrammar","async","dependencyProcessor","Promise","all","request","_loadSingleGrammar","_grammarForScopeName","_doLoadSingleGrammar","addGrammar","rawGrammar","grammarForScopeName","isIdentifier","matchesName","results","tokenizer","input","regex","exec","next","newTokenizer","charAt","parseConjunction","parseOperand","expressionToNegate","matcherInput","expressionInParents","some","parseInnerExpression","identifiers","str","plist","json_1","filePath","test","contents","JSON","parse","parseWithLocation","parsePLIST","parsePLISTGrammar","_parse","locationKeyName","advancePosBy","by","advancePosTo","to","skipWhitespace","advanceIfStartsWith","advanceUntil","nextOccurence","captureUntil","curKey","newState","newCur","dictState","arrState","leaveDict","leaveArray","acceptString","val","acceptReal","isNaN","acceptInteger","acceptDate","acceptData","acceptBool","parseOpenTag","isClosed","trim","parseTagValue","tag","peekChCode","_onigLibPromise","_grammars","_rawGrammars","_injectionGrammars","_theme","targetScope","CompiledRule","RegExpSourceList","RegExpSource","IncludeOnlyRule","MatchRule","CaptureRule","Rule","HAS_BACK_REFERENCES","BACK_REFERENCING_END","Symbol","$location","_name","_nameIsCapturing","RegexSource","hasCaptures","_contentName","_contentNameIsCapturing","location","basename","replaceCaptures","super","collectPatterns","out","_match","_cachedCompiledPatterns","_getCachedCompiledPatterns","hasMissingPatterns","pattern","begin","applyEndPatternLast","_begin","_end","hasBackReferences","resolveBackReferences","unshift","setSource","_while","_cachedCompiledWhilePatterns","_getCachedCompiledWhilePatterns","helper","desc","_compileCaptures","_compilePatterns","while","maximumCaptureId","captureId","numericCaptureId","createCaptureRule","localIncludedRule","externalGrammarName","externalGrammarInclude","externalGrammar","externalIncludedRule","skipRule","regExpSource","lastPushedPos","output","hasAnchor","nextCh","_anchorCache","_buildAnchorCache","newSource","capturedValues","capture","g1","ch","A0_G0_result","A0_G1_result","A1_G0_result","A1_G1_result","A0_G0","A0_G1","A1_G0","A1_G1","resolveAnchors","_items","_hasAnchors","_cached","_disposeCaches","item","index","regExps","e","_resolveAnchors","scanner","string","startPosition","ThemeTrieElement","ThemeTrieElementRule","ColorMap","fontStyleToString","ParsedThemeRule","parseTheme","StyleAttributes","_colorMap","_defaults","_root","_cachedMatchRoot","createFromParsedTheme","parsedThemeRules","strcmp","strArrCmp","parentScopes","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","defaults","getId","insert","resolveParsedThemeRules","effectiveRule","find","v","scopePattern","_matchesScope","_scopePathMatchesParentScopes","segments","startsWith","settings","resultLen","entry","_scope","j","lenJ","isValidHexColor","slice","style","_lastColorId","_id2color","_color2id","_isFrozen","color","toUpperCase","scopeDepth","arr","acceptOverwrite","_mainRule","rulesWithParentScopes","_children","_rulesWithParentScopes","_cmpBySpecificity","aParentScopes","bParentScopes","aParentScopesLen","bParentScopesLen","aLen","bLen","_sortBySpecificity","concat","head","tail","dotIndex","_doInsertHere","child","cloneArr","doClone","something","cloneArray","obj","cloneObj","path","idx","lastIndexOf","CAPTURING_REGEX_SOURCE","regexSource","captureSource","commandIndex","command","toLowerCase","len1","len2","hex","fn","cache","performance","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}