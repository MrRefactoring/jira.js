"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IssueAttachments = void 0;
const tslib_1 = require("tslib");
const formdata_node_1 = require("formdata-node");
class IssueAttachments {
    constructor(client) {
        this.client = client;
    }
    getAttachmentContent(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = typeof parameters === 'string' ? parameters : parameters.id;
            const config = {
                url: `/rest/api/2/attachment/content/${id}`,
                method: 'GET',
                params: {
                    redirect: typeof parameters !== 'string' && parameters.redirect,
                },
                responseType: 'arraybuffer',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    getAttachmentMeta(callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = {
                url: '/rest/api/2/attachment/meta',
                method: 'GET',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    getAttachmentThumbnail(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = typeof parameters === 'string' ? parameters : parameters.id;
            const config = {
                url: `/rest/api/2/attachment/thumbnail/${id}`,
                method: 'GET',
                params: {
                    redirect: typeof parameters !== 'string' && parameters.redirect,
                    fallbackToDefault: typeof parameters !== 'string' && parameters.fallbackToDefault,
                    width: typeof parameters !== 'string' && parameters.width,
                    height: typeof parameters !== 'string' && parameters.height,
                },
                responseType: 'arraybuffer',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    getAttachment(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = typeof parameters === 'string' ? parameters : parameters.id;
            const config = {
                url: `/rest/api/2/attachment/${id}`,
                method: 'GET',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    removeAttachment(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = typeof parameters === 'string' ? parameters : parameters.id;
            const config = {
                url: `/rest/api/2/attachment/${id}`,
                method: 'DELETE',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    expandAttachmentForHumans(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = typeof parameters === 'string' ? parameters : parameters.id;
            const config = {
                url: `/rest/api/2/attachment/${id}/expand/human`,
                method: 'GET',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    expandAttachmentForMachines(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = typeof parameters === 'string' ? parameters : parameters.id;
            const config = {
                url: `/rest/api/2/attachment/${id}/expand/raw`,
                method: 'GET',
            };
            return this.client.sendRequest(config, callback);
        });
    }
    addAttachment(parameters, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, e_1, _b, _c;
            const formData = new formdata_node_1.FormData();
            const attachments = Array.isArray(parameters.attachment) ? parameters.attachment : [parameters.attachment];
            const { default: mime } = yield import('mime');
            // eslint-disable-next-line @typescript-eslint/consistent-type-imports
            let Readable;
            if (typeof window === 'undefined') {
                const { Readable: NodeReadable } = yield import('stream');
                Readable = NodeReadable;
            }
            try {
                for (var _d = true, attachments_1 = tslib_1.__asyncValues(attachments), attachments_1_1; attachments_1_1 = yield attachments_1.next(), _a = attachments_1_1.done, !_a; _d = true) {
                    _c = attachments_1_1.value;
                    _d = false;
                    const attachment = _c;
                    const file = yield this._convertToFile(attachment, mime, Readable);
                    if (!(file instanceof formdata_node_1.File || file instanceof Blob)) {
                        throw new Error(`Unsupported file type for attachment: ${typeof file}`);
                    }
                    formData.append('file', file, attachment.filename);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = attachments_1.return)) yield _b.call(attachments_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const config = {
                url: `/rest/api/2/issue/${parameters.issueIdOrKey}/attachments`,
                method: 'POST',
                headers: {
                    'X-Atlassian-Token': 'no-check',
                    'Content-Type': 'multipart/form-data',
                },
                data: formData,
                maxBodyLength: Infinity,
                maxContentLength: Infinity,
            };
            return this.client.sendRequest(config, callback);
        });
    }
    _convertToFile(attachment, mime, 
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    Readable) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const mimeType = (_a = attachment.mimeType) !== null && _a !== void 0 ? _a : (mime.getType(attachment.filename) || undefined);
            if (attachment.file instanceof Blob || attachment.file instanceof formdata_node_1.File) {
                return attachment.file;
            }
            if (typeof attachment.file === 'string') {
                return new formdata_node_1.File([attachment.file], attachment.filename, { type: mimeType });
            }
            if (Readable && attachment.file instanceof Readable) {
                return this._streamToBlob(attachment.file, attachment.filename, mimeType);
            }
            if (attachment.file instanceof ReadableStream) {
                return this._streamToBlob(attachment.file, attachment.filename, mimeType);
            }
            if (ArrayBuffer.isView(attachment.file) || attachment.file instanceof ArrayBuffer) {
                return new formdata_node_1.File([attachment.file], attachment.filename, { type: mimeType });
            }
            throw new Error('Unsupported attachment file type.');
        });
    }
    _streamToBlob(
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    stream, filename, mimeType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof window === 'undefined' && stream instanceof (yield import('stream')).Readable) {
                return new Promise((resolve, reject) => {
                    const chunks = [];
                    stream.on('data', chunk => chunks.push(chunk));
                    stream.on('end', () => {
                        const blob = new Blob(chunks, { type: mimeType });
                        resolve(new formdata_node_1.File([blob], filename, { type: mimeType }));
                    });
                    stream.on('error', reject);
                });
            }
            if (stream instanceof ReadableStream) {
                const reader = stream.getReader();
                const chunks = [];
                let done = false;
                while (!done) {
                    const { value, done: streamDone } = yield reader.read();
                    if (value)
                        chunks.push(value);
                    done = streamDone;
                }
                const blob = new Blob(chunks, { type: mimeType });
                return new formdata_node_1.File([blob], filename, { type: mimeType });
            }
            throw new Error('Unsupported stream type.');
        });
    }
}
exports.IssueAttachments = IssueAttachments;
//# sourceMappingURL=issueAttachments.js.map